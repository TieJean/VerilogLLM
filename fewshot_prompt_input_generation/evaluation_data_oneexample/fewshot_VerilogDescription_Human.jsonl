{"task_id": "mux2to1v", "detail_description": "Create a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a 2-to-1 multiplexer with inputs A and B, selection input S, and output Y. The output Y takes the value of A when S is 0, and the value of B when S is 1.\n\n Module header:\n\nmodule \\$_NMUX_ (A, B, S, Y);\n [/INST]\n\nAssociated Code:  \n input A, B, S; \n output Y; \n assign Y = S ? !B : !A; \n endmodule"}
{"task_id": "m2014_q6b", "detail_description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a finite state machine (FSM) with four inputs (reset, clk, enable, count18, count32) and three outputs (reset_int, done, en_bclk). The FSM has three states (e_reset, e_espera, e_leer) and transitions between them based on the inputs and the current state. The done, reset_int, and en_bclk outputs are set based on the current state and the inputs. The state transitions are clocked by the positive edge of the clk input.\n\n Module header:\n\nmodule FSM(reset,clk,enable,count18,count32,reset_int,done, en_bclk);\n [/INST]\n\nAssociated Code:  \n  input wire reset; \n  input wire clk; \n  input wire enable; \n  input wire count18; \n  input wire count32; \n  output reg reset_int; \n  output reg done; \n  output reg en_bclk; \n  localparam e_reset = 2'b00; \n  localparam e_espera = 2'b01; \n  localparam e_leer = 2'b11; \n  reg [1:0] next_state = e_reset; \n  reg [1:0] state = e_reset; \n  always@(reset, enable, count18, count32, state) \n  begin \n  if(reset) \n  next_state = e_reset; \n  else \n  if((state == e_reset) && enable) \n  next_state = e_espera; \n  else \n  if((state == e_espera) && count18) \n  next_state = e_leer; \n  else \n  if((state == e_leer) && count32) \n  next_state = e_espera; \n  else \n  next_state = state; \n  end \n  always@(posedge clk) \n  if(reset) \n  state = e_reset; \n  else \n  state = next_state; \n  always@(state) \n  case (state) \n  e_reset: \n  begin \n  done = 1'b0; \n  reset_int = 1'b1; \n  en_bclk = 1'b0; \n  end \n  e_espera: \n  begin \n  done = 1'b0; \n  reset_int = 1'b0; \n  en_bclk = 1'b1; \n  end \n  e_leer: \n  begin \n  done = 1'b1; \n  reset_int = 1'b0; \n  en_bclk = 1'b1; \n  end \n  default: \n  begin \n  done = 1'b0; \n  reset_int = 1'b1; \n  en_bclk = 1'b0; \n  end \n  endcase \n endmodule"}
{"task_id": "ringer", "detail_description": "Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.Use the following description and code as an example:\nDescription: \n\nThe \"cuckooRinging\" module contains logic for controlling a buzzer. The buzzer can be activated when it's the same time and the alarm is off. The \"ringIng\" signal tracks the state of the buzzer. The \"soundFile\" register holds a 13-bit sound pattern and shifts it by one bit on each clock cycle. The \"buzzer\" output is assigned based on the combination of the \"sound\" signal and the \"ringIng\" state.\n\n Module header:\n\nmodule cuckooRinging(output buzzer,input isSameTime,input clk,input yoodRong,input onOffAlarm);\n [/INST]\n\nAssociated Code:  \n  assign ringAble = isSameTime & (!onOffAlarm); \n  reg ringIng; \n  always @(posedge ringAble, negedge yoodRong) begin \n  if(ringAble) ringIng <= 1; \n  else ringIng <= 0; \n  if(!yoodRong) ringIng <= 0; \n  end \n  reg [12:0] soundFile = 13'b0000010111111; \n  wire sound = soundFile[0]; \n  always @(posedge clk) begin \n  soundFile <= {soundFile[11:0],soundFile[12]}; \n  end \n  assign buzzer = sound&ringIng; \n endmodule"}
{"task_id": "alwaysblock1", "detail_description": "Build an AND gate using both an assign statement and a combinational always block. Use the following description and code as an example:\nDescription: \n\nThis Verilog module is designed to implement the functionality of an AND gate. It takes two input signals, a and b, and produces an output signal, out, which is the logical AND of a and b. This is achieved through the use of an assign statement which computes the AND operation between the input signals a and b and assigns the result to the output signal out.\n\n Module header:\n\nmodule andgate(a, b, out);\n [/INST]\n\nAssociated Code:  \n  input a, b; \n  output out; \n  assign out = a & b; \n endmodule"}
{"task_id": "zero", "detail_description": "Build a circuit that always outputs a LOW.Use the following description and code as an example:\nDescription: \n\nThis Verilog module simply sets the output signal G to a logical low (0) without any further logic or conditions.\n\n Module header:\n\nmodule GND(output G);\n [/INST]\n\nAssociated Code:  \n  assign G = 0; \n endmodule"}
{"task_id": "circuit7", "detail_description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         Use the following description and code as an example:\nDescription: \n\nThis Verilog module is a square wave generator that takes inputs for clock frequency, frequency, amplitude, offset, and duty cycle, and outputs a 12-bit square wave signal. The module updates the state based on the clock signal and calculates the period and duty load based on the input frequency and duty cycle. It then computes the square wave signal based on the state, offset, and amplitude, taking care to clip the output within the 12-bit range.\n\n Module header:\n\nmodule square(input clksamp,input[31:0] freq,input signed[16:0] amp,input signed[16:0] offset,input[9:0] duty,output[11:0] sq);\n [/INST]\n\nAssociated Code:  \n parameter SAMP_FREQ = 100_000_000; \n reg state = 1'b0; \n reg[15:0] period_counter = 16'b0; \n reg[15:0] duty_counter = 16'b0; \n wire[15:0] period_load = (SAMP_FREQ/freq); \n wire[15:0] duty_load = (period_load * duty) / 1000; \n reg[15:0] period_load_reg = 32'b0; \n reg[15:0] duty_load_reg = 32'b0; \n always @(posedge clksamp) begin \n  period_load_reg <= period_load; \n  duty_load_reg <= duty_load; \n  period_counter <= (period_load_reg != period_load) ? period_load_reg - 1 : (period_counter > 0) ? period_counter - 1 : period_load_reg - 1; \n  duty_counter <= (duty_load_reg != duty_load) ? duty_load_reg - 1 : (duty_counter > 0) ? duty_counter - 1 : (period_counter > 0) ? 0 : duty_load_reg - 1; \n  state <= (duty_counter == 0 && period_counter > 0) ? 0 : 1; \n end \n wire signed[16:0] preclip = state ? offset + amp : offset - amp; \n assign sq = (freq == 0 || amp == 0) ? offset > 4095 ? 4095 : offset : duty == 0 ? 0 : preclip > 4095 ? 4095 : preclip < 0 ? 0 : preclip; \n endmodule"}
{"task_id": "ece241_2014_q5a", "detail_description": "You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.Use the following description and code as an example:\nDescription: \n\nThis Verilog module, \"True2Comp\", converts a two's complement binary number into its one's complement representation. It takes in a binary input \"true\" and produces the one's complement representation in the \"complement\" output. The module is parameterized by the number of data channels and the width of each data channel. It uses a generate block to loop through the data channels and perform the conversion for each channel. The conversion is done by checking the most significant bit of each channel and either preserving the value as is or performing a bitwise complement operation.\n\n Module header:\n\nmodule True2Comp(true,complement);\n [/INST]\n\nAssociated Code:  \n  parameter data_channel = 1; \n  parameter data_width = 17; \n  input[data_channel * data_width - 1 : 0] true; \n  output[data_channel * data_width - 1 : 0] complement; \n  genvar i; \n  generate \n  `define h (i + 1) * data_width - 1 \n  `define l i * data_width \n  for (i = 0; i < data_channel; i = i + 1) begin \n  assign complement[`h : `l] = true[`h] == 0 ? \n  true[`h : `l] : {1'b1, ~true[`h - 1 : `l] + 1}; \n  end \n  `undef h \n  `undef l \n  endgenerate \n endmodule"}
{"task_id": "fsm3", "detail_description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1Use the following description and code as an example:\nDescription: \n\nThis Verilog module is a Moore finite state machine (FSM) with two input bits and one output bit. The module transitions between seven states based on the input and current state, and the output yout changes accordingly. The states and state transitions are defined with case statements and the output yout is assigned in each state based on the current state. The module operates on clock and reset signals and uses sequential and combinational logic to implement the state machine.\n\n Module header:\n\nmodule Moore_FSM(input clk,input reset,input [1:0] x,output reg yout);\n [/INST]\n\nAssociated Code:  \n  reg [2:0] state, nextState; \n  parameter s0 = 0, a0 = 1, a1 = 2, b0 = 3, b1 = 4, t0 = 5, t1 = 6; \n  always @(posedge clk or posedge reset) begin \n  if (reset) begin \n  state <= s0; \n  end \n  else begin \n  state <= nextState; \n  end \n  end \n  always @(x or state) begin \n  case (state) \n  s0: begin \n  case (x) \n  0: nextState <= s0; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  a0: begin \n  case (x) \n  0: nextState <= a1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  a1: begin \n  case (x) \n  0: nextState <= a1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  b0: begin \n  case (x) \n  0: nextState <= b1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  b1: begin \n  case (x) \n  0: nextState <= b1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  t0: begin \n  case (x) \n  0: nextState <= t1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  t1: begin \n  case (x) \n  0: nextState <= t1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  endcase \n  end \n  always @(state) begin \n  case (state) \n  s0, a1: yout <= 0; \n  a0, b0, t0: yout <= yout; \n  b1: yout <= 1; \n  t1: yout <= ~yout; \n  endcase \n  end \n endmodule"}
{"task_id": "vector2", "detail_description": "Build a circuit that reverses the byte order of a 32-bit vector.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a byte-reversal operation for a 64-bit word. It uses a generate block to iterate over the 64 bits and reverse the order of the bytes, storing the result in the output vector q_o. The module has a parameter for the number of bytes in a word and input and output vectors for the word and its reversed form, respectively. The module utilizes nested for-loops to reverse the bytes and assign them to the output vector.\n\n Module header:\n\nmodule dsi_byte_reverse (d_i,q_o);\n [/INST]\n\nAssociated Code:  \n  parameter g_num_bytes = 4; \n  input [g_num_bytes * 8 - 1 : 0] d_i; \n  output [g_num_bytes * 8 - 1 : 0] q_o; \n  generate \n  genvar i, j; \n  for(i=0;i<8;i=i+1) \n  for(j=0;j<g_num_bytes;j=j+1) \n  assign q_o[8 * (g_num_bytes-1-j) + i] = d_i[8 * j + i]; \n  endgenerate \n endmodule"}
{"task_id": "m2014_q4c", "detail_description": "Implement a simple D flip flop with active high synchronous reset (reset output to 0).Use the following description and code as an example:\nDescription: \n\nThis module implements a D flip-flop with synchronous reset functionality. The output Q is set to 1 when the reset signal R is low, and it follows the input D when the clock signal C transitions from high to low.\n\n Module header:\n\nmodule \\$_DFF_NN1_ (D, C, R, Q);\n [/INST]\n\nAssociated Code:  \n input D, C, R; \n output reg Q; \n always @(negedge C or negedge R) begin \n  if (R == 0) \n  Q <= 1; \n  else \n  Q <= D; \n end \n endmodule"}
{"task_id": "mt2015_q4a", "detail_description": "Implement the boolean function z = (x^y) & x.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a logic gate that performs a bitwise AND operation between input A and the negation of input B. The result is assigned to output Z.\n\n Module header:\n\nmodule ANDN (A,B,Z);\n [/INST]\n\nAssociated Code:  \n  input A, B; \n  output Z; \n  assign Z = A&~B; \n endmodule"}
{"task_id": "shift18", "detail_description": "Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.Use the following description and code as an example:\nDescription: \n\nThis module, named Shifter, takes in a 5-bit shift amount, a 32-bit input data, and a 2-bit shift operation. It then performs a shift operation based on the shift amount and operation, and produces a 32-bit output. The shift operation can be logical left shift, logical right shift, arithmetic right shift, or rotate left. The output is updated based on the chosen shift operation and amount.\n\n Module header:\n\nmodule Shifter(input [4:0] shift_amount,input [31:0] shift_in,input [1:0] shift_op,output reg [31:0] shift_out);\n [/INST]\n\nAssociated Code:  \n integer i; \n always@(shift_in or shift_op or shift_amount) \n begin \n shift_out={shift_in[31:0]}; \n for(i=0;i<shift_amount;i=i+1) \n case(shift_op) \n 2'b00: \n shift_out={shift_out[30:0],1'b0}; \n 2'b01: \n shift_out={1'b0,shift_out[31:1]}; \n 2'b10: \n begin \n if(shift_out[31]==0) \n shift_out={1'b0,shift_out[31:1]}; \n else \n shift_out={1'b1,shift_out[31:1]}; \n end \n 2'b11: \n shift_out={shift_out[0],shift_out[31:1]}; \n endcase \n end \n endmodule"}
{"task_id": "ece241_2013_q8", "detail_description": "Implement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a sequence detector finite state machine (FSM) that searches for a specific pattern in the input data stream. The FSM has seven states labeled S0 to S6 and transitions based on the input data_in. When the sequence is detected, the output data_out is set to 1, otherwise it is set to 0. The FSM transitions through the states based on the current state and the input data_in, and it resets to the initial state S0 on a reset signal.\n\n Module header:\n\nmodule sequence_detector_fsm(data_out, state, reset, data_in, clk);\n [/INST]\n\nAssociated Code:  \n output data_out; \n output reg [2:0] state; \n input reset, data_in, clk; \n parameter FOUND = 1'b1, \n  NOT_FOUND = 1'b0; \n parameter S0 = 3'd0, \n  S1 = 3'd1, \n  S2 = 3'd2, \n  S3 = 3'd3, \n  S4 = 3'd4, \n  S5 = 3'd5, \n  S6 = 3'd6; \n reg this_data_in; \n reg [2:0] next_state; \n always @(posedge clk or posedge reset) begin \n  if (reset) begin \n  state <= S0; \n  this_data_in <= 1'b0; \n  end else begin \n  state <= next_state; \n  this_data_in <= data_in; \n  end \n end \n assign data_out = (state == S6 ? FOUND : NOT_FOUND); \n always @(state, this_data_in) begin \n  case (state) \n  S0: next_state = (this_data_in ? S1 : S0); \n  S1: next_state = (this_data_in ? S1 : S2); \n  S2: next_state = (this_data_in ? S3 : S0); \n  S3: next_state = (this_data_in ? S1 : S4); \n  S4: next_state = (this_data_in ? S5 : S0); \n  S5: next_state = (this_data_in ? S6 : S4); \n  S6: next_state = (this_data_in ? S1 : S2); \n  default: next_state = S0; \n  endcase \n end \n endmodule"}
{"task_id": "m2014_q6", "detail_description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a finite state machine (FSM) with four inputs (reset, clk, enable, count18, count32) and three outputs (reset_int, done, en_bclk). The FSM has three states (e_reset, e_espera, e_leer) and transitions between them based on the inputs and the current state. The done, reset_int, and en_bclk outputs are set based on the current state and the inputs. The state transitions are clocked by the positive edge of the clk input.\n\n Module header:\n\nmodule FSM(reset,clk,enable,count18,count32,reset_int,done, en_bclk);\n [/INST]\n\nAssociated Code:  \n  input wire reset; \n  input wire clk; \n  input wire enable; \n  input wire count18; \n  input wire count32; \n  output reg reset_int; \n  output reg done; \n  output reg en_bclk; \n  localparam e_reset = 2'b00; \n  localparam e_espera = 2'b01; \n  localparam e_leer = 2'b11; \n  reg [1:0] next_state = e_reset; \n  reg [1:0] state = e_reset; \n  always@(reset, enable, count18, count32, state) \n  begin \n  if(reset) \n  next_state = e_reset; \n  else \n  if((state == e_reset) && enable) \n  next_state = e_espera; \n  else \n  if((state == e_espera) && count18) \n  next_state = e_leer; \n  else \n  if((state == e_leer) && count32) \n  next_state = e_espera; \n  else \n  next_state = state; \n  end \n  always@(posedge clk) \n  if(reset) \n  state = e_reset; \n  else \n  state = next_state; \n  always@(state) \n  case (state) \n  e_reset: \n  begin \n  done = 1'b0; \n  reset_int = 1'b1; \n  en_bclk = 1'b0; \n  end \n  e_espera: \n  begin \n  done = 1'b0; \n  reset_int = 1'b0; \n  en_bclk = 1'b1; \n  end \n  e_leer: \n  begin \n  done = 1'b1; \n  reset_int = 1'b0; \n  en_bclk = 1'b1; \n  end \n  default: \n  begin \n  done = 1'b0; \n  reset_int = 1'b1; \n  en_bclk = 1'b0; \n  end \n  endcase \n endmodule"}
{"task_id": "fsm_ps2data", "detail_description": "We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a finite state machine for receiving and decoding data. It has a state machine with three states: IDLE, HEADER, and DATA_OUT. It receives data on every clock edge and updates its state and output based on the received data and the current state. It also controls a data_valid signal to indicate when valid data is available. The module resets to the IDLE state when a reset signal is asserted. The module also includes a counter to keep track of the received data and control the state transitions.\n\n Module header:\n\nmodule RCB_FRL_RX_OneDataChannel(input CLKDIV,input RST,input [7:0] DATA_IN,output reg data_valid,output reg [7:0] data_out);\n [/INST]\n\nAssociated Code:  \n  reg [1:0] frame_decap_state; \n  localparam IDLE = 2'b00; \n  localparam HEADER = 2'b01; \n  localparam DATA_OUT = 2'b10; \n  reg [7:0] data_reg; \n  reg [4:0] counter; \n  always@(posedge CLKDIV) data_reg[7:0] <= DATA_IN[7:0]; \n  always@(posedge CLKDIV) begin \n  if (RST) begin \n  counter[4:0] <= 5'h00; \n  data_valid <= 1'b0; \n  data_out[7:0] <= 8'h00; \n  frame_decap_state <= IDLE; \n  end else begin \n  case (frame_decap_state) \n  IDLE: begin \n  counter[4:0] <= 5'h00; \n  data_valid <= 1'b0; \n  data_out[7:0] <= 8'h00; \n  if ( data_reg[7:0] == 8'hF5 ) \n  frame_decap_state <= HEADER; \n  else \n  frame_decap_state <= IDLE; \n  end \n  HEADER: begin \n  counter[4:0] <= 5'h00; \n  data_valid <= 1'b0; \n  data_out[7:0] <= 8'h00; \n  if ( data_reg[7:0] == 8'h1D ) \n  frame_decap_state <= DATA_OUT; \n  else if ( data_reg[7:0] == 8'hF5 ) \n  frame_decap_state <= HEADER; \n  else \n  frame_decap_state <= IDLE; \n  end \n  DATA_OUT: begin \n  counter[4:0] <= counter[4:0] + 5'h01; \n  data_valid <= 1'b1; \n  data_out[7:0] <= data_reg[7:0]; \n  if (counter >= 5'h1C) \n  frame_decap_state <= IDLE; \n  else \n  frame_decap_state <= DATA_OUT; \n  end \n  default: begin \n  counter[4:0] <= 5'h00; \n  data_valid <= 1'b0; \n  data_out[7:0] <= 8'h00; \n  frame_decap_state <= IDLE; \n  end \n  endcase \n  end \n  end \n endmodule"}
{"task_id": "2012_q2b", "detail_description": "\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\nUse the following description and code as an example:\nDescription: \n\nThis Verilog module implements a D flip-flop with an asynchronous set input. The output q is based on the input d, clock signal clk, and the set input. If set is asserted, the output q is set to 1. Otherwise, if the clock enable ce is asserted, the output q is updated with the input d. The initial value of the output q is defined by the parameter init. In a simulation environment, the functionality is implemented with a register and an assignment statement. In a hardware implementation, a Finite State Machine (FSM) is used to model the D flip-flop with an asynchronous set input.\n\n Module header:\n\nmodule dff_async_set (input d,input ce,input clk,output q,input set);\n [/INST]\n\nAssociated Code:  \n parameter init = 0; \n `ifdef COCOTB_SIM \n  reg qreg; \n  assign q = qreg; \n  always @(set or posedge clk) \n  if (set) \n  qreg <= 1; \n  else if (ce) \n  qreg <= d; \n  initial begin \n  @(clk); \n  qreg <= init; \n  end \n `else \n FDPE #(.INIT(init)) FDPE_inst (.Q(q),.C(clk),.CE(ce),.D(d),.PRE(set)); \n `endif \n endmodule"}
{"task_id": "vector0", "detail_description": "Build a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.Use the following description and code as an example:\nDescription: \n\nThis Verilog module, Mmux3d, implements a 3-input multiplexer with a parameterized bit width. It selects one of the three input data based on the control signals s0, s1, and s2, and assigns the selected data to the output register 'out'. If the control signals do not match any of the specified cases, the output is assigned to '65'hx'.\n\n Module header:\n\nmodule Mmux3d (out, in0, s0, in1, s1, in2, s2);\n [/INST]\n\nAssociated Code:  \n parameter bits = 32; \n output [bits-1:0] out; \n input [bits-1:0] in0, in1, in2; \n input s0, s1, s2; \n  reg [bits-1:0] out; \n  always @ (s0 or s1 or s2 or in0 or in1 or in2) begin \n  case ({s2, s1, s0}) \n  3'b001: out = in0; \n  3'b010: out = in1; \n  3'b100: out = in2; \n  default: out = 65'hx; \n  endcase \n  end \n endmodule"}
{"task_id": "kmap4", "detail_description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |Use the following description and code as an example:\nDescription: \n\nThis module implements a combinational circuit that takes a 12-bit input and produces a 12-bit output based on multiple XOR operations on specific bits of the input. The output bits are assigned based on different combinations of the input bits, resulting in a specific output value for each bit index.\n\n Module header:\n\nmodule d_SC_evaluation_matrix_018(i_in, o_out);\n [/INST]\n\nAssociated Code:  \n  input wire [11:0] i_in; \n  output wire [`D_SC_GF_ORDER-1:0] o_out; \n  assign o_out[0] = i_in[0] ^ i_in[4] ^ i_in[5] ^ i_in[6] ^ i_in[10]; \n  assign o_out[1] = i_in[1] ^ i_in[2] ^ i_in[3] ^ i_in[4] ^ i_in[5] ^ i_in[9] ^ i_in[10] ^ i_in[11]; \n  assign o_out[2] = i_in[2] ^ i_in[4] ^ i_in[5] ^ i_in[9] ^ i_in[10] ^ i_in[11]; \n  assign o_out[3] = i_in[2] ^ i_in[3] ^ i_in[5] ^ i_in[6] ^ i_in[7] ^ i_in[10]; \n  assign o_out[4] = i_in[1] ^ i_in[3] ^ i_in[4] ^ i_in[6] ^ i_in[7] ^ i_in[9] ^ i_in[10] ^ i_in[11]; \n  assign o_out[5] = i_in[1] ^ i_in[2] ^ i_in[4] ^ i_in[5] ^ i_in[7] ^ i_in[9] ^ i_in[10] ^ i_in[11]; \n  assign o_out[6] = i_in[1] ^ i_in[4] ^ i_in[5] ^ i_in[6] ^ i_in[7] ^ i_in[8] ^ i_in[9] ^ i_in[10]; \n  assign o_out[7] = i_in[6] ^ i_in[9]; \n  assign o_out[8] = i_in[1] ^ i_in[5] ^ i_in[7] ^ i_in[8] ^ i_in[9] ^ i_in[10]; \n  assign o_out[9] = i_in[1] ^ i_in[2] ^ i_in[3] ^ i_in[4] ^ i_in[5] ^ i_in[6] ^ i_in[8] ^ i_in[10] ^ i_in[11]; \n  assign o_out[10] = i_in[1] ^ i_in[2] ^ i_in[4] ^ i_in[5] ^ i_in[7] ^ i_in[10] ^ i_in[11]; \n  assign o_out[11] = i_in[3] ^ i_in[4] ^ i_in[8]; \n endmodule"}
{"task_id": "vector1", "detail_description": "Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.Use the following description and code as an example:\nDescription: \n\nThis module implements a 72-bit Linear Feedback Shift Register (LFSR) with a specific initial value. It uses the clock signal, reset signal, and enable signal to shift the bits of the word based on predefined logic, and updates the word accordingly.\n\n Module header:\n\nmodule rw_manager_lfsr72(clk,nrst,ena,word);\n [/INST]\n\nAssociated Code:  \n  input clk; \n  input nrst; \n  input ena; \n  output reg [71:0] word; \n  always @(posedge clk or negedge nrst) begin \n  if(~nrst) begin \n  word <= 72'hAAF0F0AA55F0F0AA55; \n  end \n  else if(ena) begin \n  word[71] <= word[0]; \n  word[70:66] <= word[71:67]; \n  word[65] <= word[66] ^ word[0]; \n  word[64:25] <= word[65:26]; \n  word[24] <= word[25] ^ word[0]; \n  word[23:19] <= word[24:20]; \n  word[18] <= word[19] ^ word[0]; \n  word[17:0] <= word[18:1]; \n  end \n  end \n endmodule"}
{"task_id": "norgate", "detail_description": "Create a module that implements a NOR gate.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a NOR gate, where the output Z is the logical negation of the OR operation between inputs A and B.\n\n Module header:\n\nmodule NOR (A,B,Z);\n [/INST]\n\nAssociated Code:  \n  input A, B; \n  output Z; \n  assign Z = ~(A|B); \n endmodule"}
{"task_id": "alwaysblock2", "detail_description": "Build an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a positive edge-triggered D flip-flop. When the clock signal CLK has a positive edge, the input D is captured and stored in the output Q after a delay of 1 time unit.\n\n Module header:\n\nmodule ff (input CLK,input D,output reg Q);\n [/INST]\n\nAssociated Code:  \n  always @ (posedge CLK) begin \n  Q <= #1 D; \n  end \n endmodule"}
{"task_id": "m2014_q6c", "detail_description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. Use the following description and code as an example:\nDescription: \n\nThis Verilog module, `tx_DS_SE`, implements a finite state machine that uses inputs `TxClk`, `TxReset`, `Tx1`, and `Tx0` to control the outputs `D` and `S`. It transitions between states based on the inputs and the current state, and resets the outputs to `0` when `TxReset` is high. The state transitions are determined by the logic expressions involving the inputs and the current state.\n\n Module header:\n\nmodule tx_DS_SE(input TxClk,input TxReset,input Tx1,input Tx0,output D,output S);\n [/INST]\n\nAssociated Code:  \n  reg D, S; \n  wire nextD = Tx1; \n  wire nextS = (Tx0 & ~(D^S)) | (Tx1 & (D^S)); \n  always @(posedge TxClk) begin \n  D <= D; \n  S <= S; \n  if(TxReset) begin \n  {D, S} <= 2'b00; \n  end \n  else if(Tx0 | Tx1) begin \n  {D, S} <= {nextD, nextS}; \n  end \n  end \n endmodule"}
{"task_id": "mux256to1", "detail_description": "Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a 16-to-1 multiplexer. It selects one of the 16 input bits based on the 4-bit selection vector S and assigns the selected bit to the output Y.\n\n Module header:\n\nmodule mux16 (D,S,Y);\n [/INST]\n\nAssociated Code:  \n  input [15:0] D; \n  input [3:0] S; \n  output Y; \n  assign Y = D[S]; \n endmodule"}
{"task_id": "2014_q4a", "detail_description": "Consider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a register-based multiplexer (MUX) controlled by the select signal, clock signal, and enable signal. The module selects between two input signals, in_a and in_b, and outputs the selected signal on the out signal. The module is tested using initial and always blocks to initialize and manipulate the input and control signals. The clock signal is toggled every time unit, the enable signal is toggled every 4 time units, the select signal is toggled every 7 time units, and the input signals in_a and in_b are incremented every 6 and 10 time units, respectively.\n\n Module header:\n\nmodule CC_MuxRegTest;\n [/INST]\n\nAssociated Code:  \n  reg clk; \n  reg sel; \n  reg en; \n  reg [3:0] in_a, in_b; \n  wire [3:0] out; \n  CC_MuxReg #(4) muxreg(sel, clk, en, in_a, in_b, out); \n  initial begin \n  sel = 0; \n  en = 0; \n  clk = 0; \n  in_a = 'b0; \n  in_b = 'b0; \n  end \n  always \n  #1 clk = ~clk; \n  always \n  #4 en = ~en; \n  always \n  #7 sel = ~sel; \n  always \n  #6 in_a = in_a + 1; \n  always \n  #10 in_b = in_b + 1; \n endmodule"}
{"task_id": "ece241_2014_q4", "detail_description": "Given the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.Use the following description and code as an example:\nDescription: \n\nThis Verilog module is a positive-edge-triggered D flip-flop with an asynchronous reset, and an enable signal. The D input is latched to the Q output when the clock signal (CLK) transitions from low to high. The output Q and its complement QN are available on the module outputs. The Q output is driven by a temporary wire Qtemp, which is derived from the D input and clock signal. The QN output is the complement of Qtemp. The D input can be optionally inverted with a 1-bit XOR gate when the enable signal (E) is asserted.\n\n Module header:\n\nmodule p_O_DFFX1 (D,CLK,Q,QN,E);\n [/INST]\n\nAssociated Code:  \n  output Q,QN; \n  input D,CLK,E; \n  wire Qtemp,Qtempt; \n  assign QN = ~Qtempt; \n  assign Q = Qtempt; \n  FD XIL_FD (.D(D),.C(CLK),.Q(Qtemp)); \n  xor(Qtempt,Qtemp,E); \n endmodule "}
{"task_id": "circuit4", "detail_description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               Use the following description and code as an example:\nDescription: \n\nThis module is a behavioral description of a combinational logic circuit with inputs cx0 and cx1 and outputs bm0 through bm7. The outputs are assigned based on logic operations like AND, NOR, and inverters on the inputs and intermediate signals n1 and n2. The module uses basic logic gates like AND2X1, NOR2X1, OAI21X1, NAND2X1, and inverters to determine the outputs based on the input conditions.\n\n Module header:\n\nmodule bmu ( cx0, cx1, bm0, bm1, bm2, bm3, bm4, bm5, bm6, bm7 );\n [/INST]\n\nAssociated Code:  \n  output [1:0] bm0; \n  output [1:0] bm1; \n  output [1:0] bm2; \n  output [1:0] bm3; \n  output [1:0] bm4; \n  output [1:0] bm5; \n  output [1:0] bm6; \n  output [1:0] bm7; \n  input cx0, cx1; \n  wire bm2_1_, bm6_1_, n1, n2; \n  assign bm1[1] = bm2_1_; \n  assign bm2[1] = bm2_1_; \n  assign bm0[1] = bm3[1]; \n  assign bm0[0] = bm3[0]; \n  assign bm1[0] = bm3[0]; \n  assign bm2[0] = bm3[0]; \n  assign bm5[1] = bm6_1_; \n  assign bm6[1] = bm6_1_; \n  assign bm4[1] = bm7[1]; \n  assign bm4[0] = bm7[0]; \n  assign bm5[0] = bm7[0]; \n  assign bm6[0] = bm7[0]; \n  AND2X1 U31 ( .A(n1), .B(cx1), .Y(bm7[1]) ); \n  NOR2X1 U32 ( .A(cx1), .B(n1), .Y(bm6_1_) ); \n  INVX1 U33 ( .A(cx0), .Y(n1) ); \n  NOR2X1 U34 ( .A(bm3[1]), .B(bm3[0]), .Y(bm2_1_) ); \n  INVX1 U35 ( .A(bm7[0]), .Y(bm3[0]) ); \n  OAI21X1 U36 ( .A(cx1), .B(cx0), .C(n2), .Y(bm7[0]) ); \n  INVX1 U37 ( .A(n2), .Y(bm3[1]) ); \n  NAND2X1 U38 ( .A(cx0), .B(cx1), .Y(n2) ); \n endmodule"}
{"task_id": "rule110", "detail_description": "Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).Use the following description and code as an example:\nDescription: \n\nThis Verilog module is an implementation of the Conway's Game of Life cellular automaton. It takes an input grid of states and applies the rules of the game to calculate the next state of each cell. The output grid of states represents the next generation of the game. The module defines the grid size using parameters WIDTH and HEIGHT. It initializes the boundary cells to zero, and for the inner cells, it calculates the sum of neighboring cell states to determine the next state using the rules of the Game of Life.\n\n Module header:\n\nmodule conway #(parameter WIDTH = 32,parameter HEIGHT = 32)(in_states,out_states);\n [/INST]\n\nAssociated Code:  \n  input [WIDTH*HEIGHT-1:0] in_states; \n  output [WIDTH*HEIGHT-1:0] out_states; \n  genvar r, c; \n  generate \n  for (c = 0; c < WIDTH; c=c+1) begin \n  assign out_states[c] = 0; \n  assign out_states[(HEIGHT-1)*WIDTH + c] = 0; \n  end \n  for (r = 1; r < HEIGHT-1; r=r+1) begin \n  assign out_states[r * WIDTH] = 0; \n  assign out_states[(r + 1) * WIDTH - 1] = 0; \n  for (c = 1; c < WIDTH-1; c=c+1) begin \n  wire cur_state_i; \n  wire [4:0] sum_i; \n  assign cur_state_i = in_states[r * WIDTH + c]; \n  assign sum_i = in_states[r * WIDTH + c-WIDTH-1] + in_states[r * WIDTH + c-WIDTH] + in_states[r * WIDTH + c-WIDTH+1] + in_states[r * WIDTH + c-1] + in_states[r * WIDTH + c+1] + in_states[r * WIDTH + c+WIDTH-1] + in_states[r * WIDTH + c+WIDTH] + in_states[r * WIDTH + c+WIDTH+1]; \n  wire eq2_i, eq3_i; \n  assign eq2_i = (sum_i == 2); \n  assign eq3_i = (sum_i == 3); \n  wire next_state_i; \n  assign next_state_i = (cur_state_i & (eq2_i | eq3_i)) | (~cur_state_i & eq3_i); \n  assign out_states[r * WIDTH + c] = next_state_i; \n  end \n  end \n  endgenerate \n endmodule"}
{"task_id": "fsm3s", "detail_description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1Use the following description and code as an example:\nDescription: \n\nThis Verilog module is a Moore finite state machine (FSM) with two input bits and one output bit. The module transitions between seven states based on the input and current state, and the output yout changes accordingly. The states and state transitions are defined with case statements and the output yout is assigned in each state based on the current state. The module operates on clock and reset signals and uses sequential and combinational logic to implement the state machine.\n\n Module header:\n\nmodule Moore_FSM(input clk,input reset,input [1:0] x,output reg yout);\n [/INST]\n\nAssociated Code:  \n  reg [2:0] state, nextState; \n  parameter s0 = 0, a0 = 1, a1 = 2, b0 = 3, b1 = 4, t0 = 5, t1 = 6; \n  always @(posedge clk or posedge reset) begin \n  if (reset) begin \n  state <= s0; \n  end \n  else begin \n  state <= nextState; \n  end \n  end \n  always @(x or state) begin \n  case (state) \n  s0: begin \n  case (x) \n  0: nextState <= s0; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  a0: begin \n  case (x) \n  0: nextState <= a1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  a1: begin \n  case (x) \n  0: nextState <= a1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  b0: begin \n  case (x) \n  0: nextState <= b1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  b1: begin \n  case (x) \n  0: nextState <= b1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  t0: begin \n  case (x) \n  0: nextState <= t1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  t1: begin \n  case (x) \n  0: nextState <= t1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  endcase \n  end \n  always @(state) begin \n  case (state) \n  s0, a1: yout <= 0; \n  a0, b0, t0: yout <= yout; \n  b1: yout <= 1; \n  t1: yout <= ~yout; \n  endcase \n  end \n endmodule"}
{"task_id": "circuit5", "detail_description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               Use the following description and code as an example:\nDescription: \n\nThis module is a behavioral description of a combinational logic circuit with inputs cx0 and cx1 and outputs bm0 through bm7. The outputs are assigned based on logic operations like AND, NOR, and inverters on the inputs and intermediate signals n1 and n2. The module uses basic logic gates like AND2X1, NOR2X1, OAI21X1, NAND2X1, and inverters to determine the outputs based on the input conditions.\n\n Module header:\n\nmodule bmu ( cx0, cx1, bm0, bm1, bm2, bm3, bm4, bm5, bm6, bm7 );\n [/INST]\n\nAssociated Code:  \n  output [1:0] bm0; \n  output [1:0] bm1; \n  output [1:0] bm2; \n  output [1:0] bm3; \n  output [1:0] bm4; \n  output [1:0] bm5; \n  output [1:0] bm6; \n  output [1:0] bm7; \n  input cx0, cx1; \n  wire bm2_1_, bm6_1_, n1, n2; \n  assign bm1[1] = bm2_1_; \n  assign bm2[1] = bm2_1_; \n  assign bm0[1] = bm3[1]; \n  assign bm0[0] = bm3[0]; \n  assign bm1[0] = bm3[0]; \n  assign bm2[0] = bm3[0]; \n  assign bm5[1] = bm6_1_; \n  assign bm6[1] = bm6_1_; \n  assign bm4[1] = bm7[1]; \n  assign bm4[0] = bm7[0]; \n  assign bm5[0] = bm7[0]; \n  assign bm6[0] = bm7[0]; \n  AND2X1 U31 ( .A(n1), .B(cx1), .Y(bm7[1]) ); \n  NOR2X1 U32 ( .A(cx1), .B(n1), .Y(bm6_1_) ); \n  INVX1 U33 ( .A(cx0), .Y(n1) ); \n  NOR2X1 U34 ( .A(bm3[1]), .B(bm3[0]), .Y(bm2_1_) ); \n  INVX1 U35 ( .A(bm7[0]), .Y(bm3[0]) ); \n  OAI21X1 U36 ( .A(cx1), .B(cx0), .C(n2), .Y(bm7[0]) ); \n  INVX1 U37 ( .A(n2), .Y(bm3[1]) ); \n  NAND2X1 U38 ( .A(cx0), .B(cx1), .Y(n2) ); \n endmodule"}
{"task_id": "bugs_mux2", "detail_description": "Find the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmoduleUse the following description and code as an example:\nDescription: \n\nThis Verilog module implements a 2-to-1 multiplexer with a parameterized bit length. It takes two inputs, mux_in0 and mux_in1, and a selection input mux_sel. When mux_sel is high, the module selects mux_in1 as the output; otherwise, it selects mux_in0. The output mux_out is assigned the selected input value.\n\n Module header:\n\nmodule MUXn_2_1(mux_in0, mux_in1, mux_sel, mux_out);\n [/INST]\n\nAssociated Code:  \n  parameter MuxLen = 63; \n  output [MuxLen:0] mux_out; \n  input [MuxLen:0] mux_in0; \n  input [MuxLen:0] mux_in1; \n  input mux_sel; \n  reg [MuxLen:0] mux_out; \n  always @(mux_in0 or mux_in1 or mux_sel) \n  begin \n  if (mux_sel == 1'b1) \n  mux_out = mux_in1; \n  else \n  mux_out = mux_in0; \n  end \n endmodule "}
{"task_id": "mt2015_muxdff", "detail_description": "Consider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\nUse the following description and code as an example:\nDescription: \n\nThis Verilog module, named TopModule, instantiates SubModule1 and interfaces with it by connecting signals and passing values between them. It has inputs for clk, rst, sig, and flip, and outputs passThrough, outOther, and sig_out. The module assigns MyInterfaceInstance_mysig_out to sig_out and MyInterfaceInstance_setting to flip. It also declares and assigns other internal signals such as MyInterfaceInstance_other_setting and MyInterfaceInstance_setting. This module essentially acts as a top-level wrapper for the SubModule1, handling the interface between the SubModule1 and the rest of the system.\n\n Module header:\n\nmodule TopModule(input logic clk,input logic rst,input logic [1:0] sig,input logic flip,output logic [15:0] passThrough,output logic [21:0] outOther,output logic [1:0] sig_out);\n [/INST]\n\nAssociated Code:  \n  logic MyInterfaceInstance_setting; \n  logic [3:0] MyInterfaceInstance_other_setting; \n  logic [1:0] MyInterfaceInstance_mysig_out; \n SubModule1 u_SubModule1 (.clk(clk),.rst(rst),.u_MyInterface_setting(MyInterfaceInstance_setting),.u_MyInterface_mysig_out(MyInterfaceInstance_mysig_out),.u_MyInterface_other_setting(MyInterfaceInstance_other_setting),.outOther(outOther),.passThrough (passThrough),.sig (sig)); \n  assign sig_out = MyInterfaceInstance_mysig_out; \n  assign MyInterfaceInstance_setting = flip; \n endmodule"}
{"task_id": "edgecapture", "detail_description": "For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a bit capture control logic for a communication interface. It uses the input clocks and reset signal to capture and store incoming data bits. When the reset signal is asserted, it sets certain output bits to 0. Otherwise, it captures the input data and propagates it through to the corresponding output bits based on the clock edges.\n\n Module header:\n\nmodule bit_capture_control(input negedge_clk,input posedge_clk,input rx_resetn,input rx_din,output reg bit_c_0,output reg bit_c_1,output reg bit_c_2,output reg bit_c_3);\n [/INST]\n\nAssociated Code:  \n always@(posedge posedge_clk or negedge rx_resetn) \n begin \n  if(!rx_resetn) \n  begin \n  bit_c_1 <= 1'b0; \n  bit_c_3 <= 1'b0; \n  end \n  else \n  begin \n  bit_c_1 <= rx_din; \n  bit_c_3 <= bit_c_1; \n  end \n end \n always@(posedge negedge_clk or negedge rx_resetn) \n begin \n  if(!rx_resetn) \n  begin \n  bit_c_0 <= 1'b0; \n  bit_c_2 <= 1'b0; \n  end \n  else \n  begin \n  bit_c_0 <= rx_din; \n  bit_c_2 <= bit_c_0; \n  end \n end \n endmodule"}
{"task_id": "dff8", "detail_description": "Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a positive edge-triggered D flip-flop with asynchronous preset functionality. The output q is initialized to 0 and updates to 1 on the positive edge of the clock if the pre input is asserted; otherwise, it updates to the value of the d input on the positive edge of the clock.\n\n Module header:\n\nmodule my_dffs_clk_p (input d,clk,pre,output reg q);\n [/INST]\n\nAssociated Code:  \n  initial q <= 0; \n  always @(posedge clk) \n  if (pre) q <= 1'b1; \n  else q <= d; \n endmodule"}
{"task_id": "ece241_2014_q1c", "detail_description": "Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.Use the following description and code as an example:\nDescription: \n\nThis Verilog module Test2 computes the sum of two signed 8-bit numbers, b and c. It assigns the value 3 to b and -1 to c, and then computes the sum of b and c, storing the result in the 8-bit output as.\n\n Module header:\n\nmodule Test2 (output [7:0] as);\n [/INST]\n\nAssociated Code:  \n  wire signed [7:0] b; \n  wire signed [3:0] c; \n  assign c=-1; \n  assign b=3; \n  assign as=b+c; \n endmodule"}
{"task_id": "review2015_fsmonehot", "detail_description": "Given the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\nUse the following description and code as an example:\nDescription: \n\nThis Verilog module is a Moore state machine that generates outputs a and b based on the input signals clk, rst_n, and enb. The module has five states: IN_FINAL, IN_IDLE, IN_INITIAL, IN_SEQ1, and IN_SEQ2. It uses real data type for a_1, b_1, a_reg, and b_reg, and updates their values based on the current state and input signals. The outputs a and b are assigned the converted real values of a_1 and b_1. The module transitions between states based on the current state, and updates the next state and the registers a_reg_next and b_reg_next accordingly.\n\n Module header:\n\nmodule Moore_Chart (clk,rst_n,enb,a,b);\n [/INST]\n\nAssociated Code:  \n  input clk; \n  input rst_n; \n  input enb; \n  output [63:0] a; \n  output [63:0] b; \n  parameter IN_FINAL = 3'd0, IN_IDLE = 3'd1, IN_INITIAL = 3'd2, IN_SEQ1 = 3'd3, IN_SEQ2 = 3'd4; \n  reg [2:0] is_Moore_Chart; \n  real a_1; \n  real b_1; \n  real a_reg; \n  real b_reg; \n  reg [2:0] is_Moore_Chart_next; \n  real a_reg_next; \n  real b_reg_next; \n  always @(posedge clk or negedge rst_n) \n  begin : Moore_Chart_1_process \n  if (rst_n == 1'b0) begin \n  is_Moore_Chart <= IN_INITIAL; \n  end \n  else begin \n  if (enb) begin \n  is_Moore_Chart <= is_Moore_Chart_next; \n  a_reg <= a_reg_next; \n  b_reg <= b_reg_next; \n  end \n  end \n  end \n  always @* begin \n  is_Moore_Chart_next = is_Moore_Chart; \n  a_reg_next = a_reg; \n  b_reg_next = b_reg; \n  case ( is_Moore_Chart) \n  IN_FINAL : \n  begin \n  end \n  IN_IDLE : \n  begin \n  a_reg_next = 0.0; \n  end \n  IN_INITIAL : \n  begin \n  a_reg_next = 0.0; \n  b_reg_next = 0.0; \n  end \n  IN_SEQ1 : \n  begin \n  a_reg_next = 1.0; \n  b_reg_next = b_reg + 1.0; \n  end \n  endcase \n  case ( is_Moore_Chart) \n  IN_FINAL : \n  begin \n  is_Moore_Chart_next = IN_IDLE; \n  end \n  IN_IDLE : \n  begin \n  is_Moore_Chart_next = IN_SEQ1; \n  end \n  IN_INITIAL : \n  begin \n  is_Moore_Chart_next = IN_IDLE; \n  end \n  IN_SEQ1 : \n  begin \n  is_Moore_Chart_next = IN_SEQ2; \n  end \n  default : \n  begin \n  is_Moore_Chart_next = IN_FINAL; \n  end \n  endcase \n  end \n  always @* a_1 = a_reg_next; \n  always @* b_1 = b_reg_next; \n  assign a = $realtobits(a_1); \n  assign b = $realtobits(b_1); \n endmodule "}
{"task_id": "counter_2bc", "detail_description": "Build a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.Use the following description and code as an example:\nDescription: \n\nThis Verilog module is a counter with asynchronous reset and enables control. It has a parameter N for defining the width of the counter, and an always block sensitive to the positive edge of the clock. It checks the enable input to control the counter operation. When reset is asserted, the counter is cleared. When the input data matches a specific value and a data-valid signal is high, the counter is either incremented or decremented based on its current value. If none of these conditions are met, the counter retains its current value.\n\n Module header:\n\nmodule Contador_AD(input rst,input [1:0] en,input [7:0] Cambio,input got_data,input clk,output reg [(N-1):0] Cuenta);\n [/INST]\n\nAssociated Code:  \n  parameter N = 6; \n  parameter X = 59; \n  always @(posedge clk) \n  if (en == 2'd0) \n  begin \n  if (rst) \n  Cuenta <= 0; \n  else if (Cambio == 8'h75 && got_data) \n  begin \n  if (Cuenta == X) \n  Cuenta <= 0; \n  else \n  Cuenta <= Cuenta + 1'd1; \n  end \n  else if (Cambio == 8'h72 && got_data) \n  begin \n  if (Cuenta == 0) \n  Cuenta <= X; \n  else \n  Cuenta <= Cuenta - 1'd1; \n  end \n  else \n  Cuenta <= Cuenta; \n  end \n  else Cuenta <= Cuenta; \n endmodule"}
{"task_id": "always_casez", "detail_description": "Build a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.Use the following description and code as an example:\nDescription: \n\nThis module implements a priority encoder using the assign statement. It takes a 16-bit input and based on the enable signal, it outputs a 4-bit binary number representing the highest-order bit that is set in the input. If enable is low, the output is 0000. If enable is high, the output corresponds to the highest-order bit set in the input, with bit 15 being the highest priority and bit 0 being the lowest priority.\n\n Module header:\n\nmodule pri_encoder_using_assign (binary_out ,encoder_in ,enable);\n [/INST]\n\nAssociated Code:  \n output [3:0] binary_out ; \n input enable ; \n input [15:0] encoder_in ; \n wire [3:0] binary_out ; \n assign binary_out = (!enable) ? 0 : ((encoder_in == 16'bxxxx_xxxx_xxxx_xxx1) ? 0 :(encoder_in == 16'bxxxx_xxxx_xxxx_xx10) ? 1 :(encoder_in == 16'bxxxx_xxxx_xxxx_x100) ? 2 :(encoder_in == 16'bxxxx_xxxx_xxxx_1000) ? 3 :(encoder_in == 16'bxxxx_xxxx_xxx1_0000) ? 4 :(encoder_in == 16'bxxxx_xxxx_xx10_0000) ? 5 :(encoder_in == 16'bxxxx_xxxx_x100_0000) ? 6 :(encoder_in == 16'bxxxx_xxxx_1000_0000) ? 7 :(encoder_in == 16'bxxxx_xxx1_0000_0000) ? 8 :(encoder_in == 16'bxxxx_xx10_0000_0000) ? 9 :(encoder_in == 16'bxxxx_x100_0000_0000) ? 10 :(encoder_in == 16'bxxxx_1000_0000_0000) ? 11 :(encoder_in == 16'bxxx1_0000_0000_0000) ? 12 :(encoder_in == 16'bxx10_0000_0000_0000) ? 13 :(encoder_in == 16'bx100_0000_0000_0000) ? 14 : 15); \n endmodule "}
{"task_id": "always_nolatches", "detail_description": "Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\nUse the following description and code as an example:\nDescription: \n\nThis Verilog module is a PS2 keyboard decoder. It includes a state machine that processes the keyboard input and generates the corresponding scan code. The state machine transitions through different states to capture and validate the received data. The scan code is generated and stored in the r_scan_code register, and the ready signal is used to indicate when a valid scan code is available.\n\n Module header:\n\nmodule ps2decoder (input reset,input i_clock,input i_data,output scan_ready,output [7:0] scan_code);\n [/INST]\n\nAssociated Code:  \n  reg [7:0] r_scan_code; \n  reg [3:0] state_reg; \n  reg ready; \n  assign scan_code = r_scan_code; \n  assign scan_ready = ready; \n  always @(negedge i_clock or posedge reset) begin \n  if (reset) begin \n  state_reg <= 4'b0; \n  r_scan_code <= 8'b0; \n  end \n  else begin \n  case (state_reg) \n  4'd0: \n  begin \n  state_reg <= state_reg + 1'b1; \n  ready <= 1'b0; \n  end \n  4'd9: \n  begin \n  if (!i_data == ^r_scan_code) begin \n  ready <= 1'b1; \n  end else begin \n  ready <= 1'b0; \n  end \n  state_reg <= state_reg + 1'b1; \n  end \n  4'd10: \n  begin \n  state_reg <= 4'b0; \n  ready <= 1'b0; \n  end \n  default: \n  begin \n  r_scan_code[state_reg - 1] <= i_data; \n  state_reg <= state_reg + 1'b1; \n  ready <= 1'b0; \n  end \n  endcase \n  end \n  end \n endmodule"}
{"task_id": "m2014_q4j", "detail_description": "Implement a 4-bit adder with full adders. The output sum should include the overflow bit.Use the following description and code as an example:\nDescription: \n\nThis module implements a 4-bit adder using four full adder instances to perform the addition of two 4-bit inputs A and B. The carry-out of each full adder is connected to the carry-in of the next full adder. The output SUM is a 5-bit vector representing the sum of the input vectors A and B.\n\n Module header:\n\nmodule four_bit_adder (input [3:0] A,input [3:0] B,output [4:0] SUM);\n [/INST]\n\nAssociated Code:  \n  wire CARRY0; \n  assign CARRY0 = 1'b0; \n  full_adder op1 (A[0], B[0], CARRY0, SUM[0], CARRY1); \n  full_adder op2 (A[1], B[1], CARRY1, SUM[1], CARRY2); \n  full_adder op3 (A[2], B[2], CARRY2, SUM[2], CARRY3); \n  full_adder op4 (A[3], B[3], CARRY3, SUM[3], SUM[4]); \n endmodule"}
{"task_id": "history_shift", "detail_description": "Build a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\nUse the following description and code as an example:\nDescription: \n\nThe Verilog module is designed for branch prediction. It takes various input signals such as clock, reset, operand flags, and immediate jump branch upper bits, and outputs the predicted flag and whether a branch misprediction has occurred. The predicted flag is determined based on the operand flags and immediate jump branch upper bits. The module also checks for branch misprediction based on the previous branch condition and the previously predicted flag.\n\n Module header:\n\nmodule mor1kx_branch_prediction #(parameter OPTION_OPERAND_WIDTH = 32) (input clk,input rst,input op_bf_i,input op_bnf_i,input [9:0] immjbr_upper_i,output predicted_flag_o,input prev_op_brcond_i,input prev_predicted_flag_i,input flag_i,output branch_mispredict_o);\n [/INST]\n\nAssociated Code:  \n  assign branch_mispredict_o = prev_op_brcond_i & \n  (flag_i != prev_predicted_flag_i); \n  assign predicted_flag_o = op_bf_i & immjbr_upper_i[9] | \n  op_bnf_i & !immjbr_upper_i[9]; \n endmodule"}
{"task_id": "wire_decl", "detail_description": "Implement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.Use the following description and code as an example:\nDescription: \n\nThis Verilog module, omsp_and_gate, implements a 2-input AND gate. It takes two input signals, a and b, and generates an output signal y that represents the logical AND of inputs a and b.\n\n Module header:\n\nmodule omsp_and_gate (y,a,b);\n [/INST]\n\nAssociated Code:  \n output y; \n input a; \n input b; \n assign y = a & b; \n endmodule "}
{"task_id": "dff", "detail_description": "Create a single D flip-flop.Use the following description and code as an example:\nDescription: \n\nThis Verilog module is a General Purpose D Flip-Flop with Set capability. It has an input D, clock signal CLK, negative Set signal nSET, and output Q. The initial value of Q is set to 1'bx. When nSET is low, Q is set to 1'bx. When nSET is high, Q is set to 1'b1 initially and then follows the input D.\n\n Module header:\n\nmodule GP_DFFS(input D, CLK, nSET, output reg Q);\n [/INST]\n\nAssociated Code:  \n  parameter [0:0] INIT = 1'bx; \n  initial Q = INIT; \n  always @(posedge CLK, negedge nSET) begin \n  if (!nSET) \n  Q <= 1'b1; \n  else \n  Q <= D; \n  end \n endmodule"}
{"task_id": "ece241_2013_q12", "detail_description": "In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. Use the following description and code as an example:\nDescription: \n\nThe Verilog module `MUX8_1_ALU` implements an 8-to-1 multiplexer. It selects one of the 8 inputs `S0` through `S7` based on the 3-bit input `Sel`. The output `ALU_out` carries the value of the selected input. The selection is implemented using a cascaded ternary operator which checks each bit of `Sel` to determine the selected input.\n\n Module header:\n\nmodule MUX8_1_ALU(Sel,S0,S1,S2,S3,S4,S5,S6,S7,ALU_out);\n [/INST]\n\nAssociated Code:  \n input [2:0] Sel; \n input [31:0] S0,S1,S2,S3,S4,S5,S6,S7; \n output [31:0]ALU_out; \n assign ALU_out = (Sel[2])? (Sel[1]?(Sel[0]?S7:S6) : (Sel[0]?S5:S4)) : (Sel[1]?(Sel[0]?S3:S2) : (Sel[0]?S1:S0)); \n endmodule"}
{"task_id": "thermostat", "detail_description": "A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.Use the following description and code as an example:\nDescription: \n\nThis Verilog module is named SystemMonitor and instantiates a TemperatureMonitor module called SysMon1. It has inputs for a clock signal, an address, and outputs for ready signal and data. The module also has internal wires for data enable, data write enable, and voltage inputs. Additionally, it assigns values to the internal wires and an input data signal. The TemperatureMonitor module interfaces with these signals to monitor temperature and provide an output data result.\n\n Module header:\n\nmodule SystemMonitor(input wire clk,input wire [6:0] DADDR_IN,output wire DRDY_OUT,output wire [15:0] DO_OUT);\n [/INST]\n\nAssociated Code:  \n wire DEN_IN, DWE_IN, VP_IN, VN_IN; \n wire [15:0] DI_IN; \n assign DEN_IN = 1'b1; \n assign DWE_IN = 1'b0; \n assign VP_IN = 1'b0; \n assign VN_IN = 1'b0; \n assign DI_IN = 16'h0000; \n TemperatureMonitor SysMon1(.DADDR_IN(DADDR_IN[6:0]),.DCLK_IN(clk),.DEN_IN(DEN_IN),.DI_IN(DI_IN[15:0]),.DWE_IN(DWE_IN),.DO_OUT(DO_OUT[15:0]),.DRDY_OUT(DRDY_OUT),.VP_IN(VP_IN),.VN_IN(VN_IN)); \n endmodule"}
{"task_id": "ece241_2013_q2", "detail_description": "A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\nUse the following description and code as an example:\nDescription: \n\nThis Verilog module implements an 8-bit binary adder with the inputs in1 and in2, and the output stored in the res. The input bits are added in groups of 2, with carry-out from the previous group taken into account. The module includes intermediate logic gates for AND, XOR, and OR operations, as well as temporary wires to store partial sums and carry-out values. The outputs are generated by combining the partial sum values.\n\n Module header:\n\nmodule GDA_St_N8_M4_P2(input [7:0] in1,input [7:0] in2,output [8:0] res);\n [/INST]\n\nAssociated Code:  \n wire [2:0] temp1, temp2, temp3, temp4; \n wire g0,g1,p0,p1; \n wire p1g0; \n wire c2; \n and and_0(g0,in1[0],in2[0]); \n and and_1(g1,in1[1],in2[1]); \n xor xor_0(p0,in1[0],in2[0]); \n xor xor_1(p1,in1[1],in2[1]); \n and and_2(p1g0,p1,g0); \n or or_1 (c2,g1,p1g0); \n wire g2,g3,p2,p3; \n wire p3g2; \n wire c4; \n and and_3(g2,in1[2],in2[2]); \n and and_4(g3,in1[3],in2[3]); \n xor xor_2(p2,in1[2],in2[2]); \n xor xor_3(p3,in1[3],in2[3]); \n and and_5(p3g2,p3,g2); \n or or_2 (c4,g3,p3g2); \n wire g4,g5,p4,p5; \n wire p5g4; \n wire c6; \n and and_8(g4,in1[4],in2[4]); \n and and_9(g5,in1[5],in2[5]); \n xor xor_4(p4,in1[4],in2[4]); \n xor xor_5(p5,in1[5],in2[5]); \n and and_10(p5g4,p5,g4); \n or or_4 (c6,g5,p5g4); \n assign temp1[2:0] = in1[1:0] + in2[1:0]; \n assign temp2[2:0] = in1[3:2] + in2[3:2] + c2; \n assign temp3[2:0] = in1[5:4] + in2[5:4] + c4; \n assign temp4[2:0] = in1[7:6] + in2[7:6] + c6; \n assign res[8:0] = {temp4[2:0],temp3[1:0],temp2[1:0],temp1[1:0]}; \n endmodule"}
{"task_id": "lfsr32", "detail_description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.Use the following description and code as an example:\nDescription: \n\nThe Verilog module lfsr13 implements a 13-bit linear feedback shift register (LFSR). It has inputs for clock (clk), reset (rst), and enable (ena), and outputs the 13-bit state. The state is initialized to 1 on reset and shifts by one bit on each clock cycle when enabled. The output of the XOR gate is used to update the first bit of the state.\n\n Module header:\n\nmodule lfsr13(clk, rst, ena, state);\n [/INST]\n\nAssociated Code:  \n  input clk, rst, ena; \n  output [12:0] state; \n  reg [12:0] state; \n  always @(posedge rst or posedge clk) begin \n  if (rst == 1) begin \n  state <= 1; \n  end else if (ena) begin \n  state[12:1] <= state[11:0]; \n  state[0] <= state[7] ^ state[10] ^ state[11] ^ state[12]; \n  end \n  end \n endmodule"}
{"task_id": "circuit3", "detail_description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               Use the following description and code as an example:\nDescription: \n\nThis module is a behavioral description of a combinational logic circuit with inputs cx0 and cx1 and outputs bm0 through bm7. The outputs are assigned based on logic operations like AND, NOR, and inverters on the inputs and intermediate signals n1 and n2. The module uses basic logic gates like AND2X1, NOR2X1, OAI21X1, NAND2X1, and inverters to determine the outputs based on the input conditions.\n\n Module header:\n\nmodule bmu ( cx0, cx1, bm0, bm1, bm2, bm3, bm4, bm5, bm6, bm7 );\n [/INST]\n\nAssociated Code:  \n  output [1:0] bm0; \n  output [1:0] bm1; \n  output [1:0] bm2; \n  output [1:0] bm3; \n  output [1:0] bm4; \n  output [1:0] bm5; \n  output [1:0] bm6; \n  output [1:0] bm7; \n  input cx0, cx1; \n  wire bm2_1_, bm6_1_, n1, n2; \n  assign bm1[1] = bm2_1_; \n  assign bm2[1] = bm2_1_; \n  assign bm0[1] = bm3[1]; \n  assign bm0[0] = bm3[0]; \n  assign bm1[0] = bm3[0]; \n  assign bm2[0] = bm3[0]; \n  assign bm5[1] = bm6_1_; \n  assign bm6[1] = bm6_1_; \n  assign bm4[1] = bm7[1]; \n  assign bm4[0] = bm7[0]; \n  assign bm5[0] = bm7[0]; \n  assign bm6[0] = bm7[0]; \n  AND2X1 U31 ( .A(n1), .B(cx1), .Y(bm7[1]) ); \n  NOR2X1 U32 ( .A(cx1), .B(n1), .Y(bm6_1_) ); \n  INVX1 U33 ( .A(cx0), .Y(n1) ); \n  NOR2X1 U34 ( .A(bm3[1]), .B(bm3[0]), .Y(bm2_1_) ); \n  INVX1 U35 ( .A(bm7[0]), .Y(bm3[0]) ); \n  OAI21X1 U36 ( .A(cx1), .B(cx0), .C(n2), .Y(bm7[0]) ); \n  INVX1 U37 ( .A(n2), .Y(bm3[1]) ); \n  NAND2X1 U38 ( .A(cx0), .B(cx1), .Y(n2) ); \n endmodule"}
{"task_id": "7420", "detail_description": "The 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a circuit that connects 16 D flip-flops to 16 switches and a 4-bit input, and then outputs the 4-bit input and the flip-flop outputs to seven-segment displays. The circuit also uses a 4-bit keypad input to control the clocking and clearing of the flip-flops.\n\n Module header:\n\nmodule lab3_part5 (SW, HEX7, HEX6, HEX5, HEX4, HEX3, HEX2, HEX1, HEX0, KEY);\n [/INST]\n\nAssociated Code:  \n  input [3:0] KEY; \n  input [17:0] SW; \n  output [0:6] HEX7, HEX6, HEX5, HEX4, HEX3, HEX2, HEX1, HEX0; \n  reg [15:0] R; \n  wire [15:0] Q; \n  D_ff_with_sync_clr F0 (~KEY[1], SW[0], Q[0], ~KEY[0]); \n  D_ff_with_sync_clr F1 (~KEY[1], SW[1], Q[1], ~KEY[0]); \n  D_ff_with_sync_clr F2 (~KEY[1], SW[2], Q[2], ~KEY[0]); \n  D_ff_with_sync_clr F3 (~KEY[1], SW[3], Q[3], ~KEY[0]); \n  D_ff_with_sync_clr F4 (~KEY[1], SW[4], Q[4], ~KEY[0]); \n  D_ff_with_sync_clr F5 (~KEY[1], SW[5], Q[5], ~KEY[0]); \n  D_ff_with_sync_clr F6 (~KEY[1], SW[6], Q[6], ~KEY[0]); \n  D_ff_with_sync_clr F7 (~KEY[1], SW[7], Q[7], ~KEY[0]); \n  D_ff_with_sync_clr F8 (~KEY[1], SW[8], Q[8], ~KEY[0]); \n  D_ff_with_sync_clr F9 (~KEY[1], SW[9], Q[9], ~KEY[0]); \n  D_ff_with_sync_clr F10 (~KEY[1], SW[10], Q[10], ~KEY[0]); \n  D_ff_with_sync_clr F11 (~KEY[1], SW[11], Q[11], ~KEY[0]); \n  D_ff_with_sync_clr F12 (~KEY[1], SW[12], Q[12], ~KEY[0]); \n  D_ff_with_sync_clr F13 (~KEY[1], SW[13], Q[13], ~KEY[0]); \n  D_ff_with_sync_clr F14 (~KEY[1], SW[14], Q[14], ~KEY[0]); \n  D_ff_with_sync_clr F15 (~KEY[1], SW[15], Q[15], ~KEY[0]); \n  always \n  R = Q; \n  hex_ssd H0 (SW[3:0], HEX0); \n  hex_ssd H1 (SW[7:4], HEX1); \n  hex_ssd H2 (SW[11:8], HEX2); \n  hex_ssd H3 (SW[15:12], HEX3); \n  hex_ssd H4 (R[3:0], HEX4); \n  hex_ssd H5 (R[7:4], HEX5); \n  hex_ssd H6 (R[11:8], HEX6); \n  hex_ssd H7 (R[15:12], HEX7); \n endmodule"}
{"task_id": "popcount255", "detail_description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.Use the following description and code as an example:\nDescription: \n\nThis module is designed to count the number of active inputs (func_rb0 to func_rb15) and output the count in binary through the four-bit vector oCOUNT. The count is computed by incrementing a temporary four-bit register, func_rb_tmp_count, by 1 for each active input. The count is then assigned to the output oCOUNT.\n\n Module header:\n\nmodule reservation_free_entry_count(input wire iINFO0,input wire iINFO1,input wire iINFO2,input wire iINFO3,input wire iINFO4,input wire iINFO5,input wire iINFO6,input wire iINFO7,input wire iINFO8,input wire iINFO9,input wire iINFO10,input wire iINFO11,input wire iINFO12,input wire iINFO13,input wire iINFO14,input wire iINFO15,output wire [3:0] oCOUNT);\n [/INST]\n\nAssociated Code:  \n assign oCOUNT = func_rb_free_count16(iINFO0, iINFO1, iINFO2, iINFO3,iINFO4, iINFO5, iINFO6, iINFO7,iINFO8, iINFO9, iINFO10, iINFO11,iINFO12, iINFO13, iINFO14, iINFO15); \n  function [3:0] func_rb_free_count16; \n  input func_rb0; \n  input func_rb1; \n  input func_rb2; \n  input func_rb3; \n  input func_rb4; \n  input func_rb5; \n  input func_rb6; \n  input func_rb7; \n  input func_rb8; \n  input func_rb9; \n  input func_rb10; \n  input func_rb11; \n  input func_rb12; \n  input func_rb13; \n  input func_rb14; \n  input func_rb15; \n  reg [3:0] func_rb_tmp_count; \n  begin \n  func_rb_tmp_count = 4'h0; \n  if(func_rb0)begin \n  func_rb_tmp_count = func_rb_tmp_count + 4'h1; \n  end \n  if(func_rb1)begin \n  func_rb_tmp_count = func_rb_tmp_count + 4'h1; \n  end \n  if(func_rb2)begin \n  func_rb_tmp_count = func_rb_tmp_count + 4'h1; \n  end \n  if(func_rb3)begin \n  func_rb_tmp_count = func_rb_tmp_count + 4'h1; \n  end \n  if(func_rb4)begin \n  func_rb_tmp_count = func_rb_tmp_count + 4'h1; \n  end \n  if(func_rb5)begin \n  func_rb_tmp_count = func_rb_tmp_count + 4'h1; \n  end \n  if(func_rb6)begin \n  func_rb_tmp_count = func_rb_tmp_count + 4'h1; \n  end \n  if(func_rb7)begin \n  func_rb_tmp_count = func_rb_tmp_count + 4'h1; \n  end \n  if(func_rb8)begin \n  func_rb_tmp_count = func_rb_tmp_count + 4'h1; \n  end \n  if(func_rb9)begin \n  func_rb_tmp_count = func_rb_tmp_count + 4'h1; \n  end \n  if(func_rb10)begin \n  func_rb_tmp_count = func_rb_tmp_count + 4'h1; \n  end \n  if(func_rb11)begin \n  func_rb_tmp_count = func_rb_tmp_count + 4'h1; \n  end \n  if(func_rb12)begin \n  func_rb_tmp_count = func_rb_tmp_count + 4'h1; \n  end \n  if(func_rb13)begin \n  func_rb_tmp_count = func_rb_tmp_count + 4'h1; \n  end \n  if(func_rb14)begin \n  func_rb_tmp_count = func_rb_tmp_count + 4'h1; \n  end \n  if(func_rb15)begin \n  func_rb_tmp_count = func_rb_tmp_count + 4'h1; \n  end \n  func_rb_free_count16 = func_rb_tmp_count; \n  end \n  endfunction \n endmodule"}
{"task_id": "gatesv", "detail_description": "You are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].Use the following description and code as an example:\nDescription: \n\nThis Verilog module compares the bits of two 8-bit input vectors 'a' and 'b'. It uses a for loop to iterate through each bit position and performs a bitwise XOR operation between the corresponding bits of 'a' and 'b'. The result of this XOR operation is then inverted and stored in the 'match' output vector, effectively indicating which bits in 'a' and 'b' are matching.\n\n Module header:\n\nmodule match_bits_v(input [7:0] a,b, output reg [7:0] match);\n [/INST]\n\nAssociated Code:  \n  integer i; \n  wire ab_xor; \n  always @(a or b) begin \n  for (i=7; i>=0; i=i-1) begin \n  match[i] = ~(a[i]^b[i]); \n  end \n  end \n endmodule"}
{"task_id": "circuit6", "detail_description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            Use the following description and code as an example:\nDescription: \n\nThis module is a circuit that operates on a clock signal and a data input to produce a quantum output. It uses several internal registers to maintain state information. The behavior of the module is controlled by clock edges and the data input. The output q is dependent on the current state and the data input, and the state is updated based on the data input and the value of another internal register. The module also includes initialization with random values if `RANDOM_INIT` is defined.\n\n Module header:\n\nmodule pext_p2_4 ( clk, d, q );\n [/INST]\n\nAssociated Code:  \n  input clk; \n  input d; \n  output q; \n  reg q; \n  reg c_q; \n  reg [1:0] r_cnt; \n  reg [1:0] c_cnt; \n  reg [1:0] cig_zerocnt; \n `ifdef RANDOM_INIT \n  initial begin \n  $random_init(\"q\", \"r_cnt\"); \n  end \n `endif \n  always @(posedge clk) begin \n  r_cnt <= \n  (^c_cnt === 1'bx) ? $random : \n  c_cnt; \n  q <= c_q; \n  end \n  always @ (d or q or r_cnt) begin \n  cig_zerocnt = 2'b0; \n  c_cnt = d ? ~cig_zerocnt : {r_cnt - ((|r_cnt) ? 2'b1 : 2'b0)}; \n  c_q = d | (|r_cnt); \n  end \n endmodule"}
{"task_id": "countslow", "detail_description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a ticker with adjustable speed based on the input level. It counts cycles and increments a tick output based on the clock signal. When the count reaches a specific value determined by the input level, the tick output is set, and the count is reset. The ticker also has a reset input that clears all internal counters and sets the tick output to 0.\n\n Module header:\n\nmodule ticker(input clk, input[7:0] level, output reg tick, input rst);\n [/INST]\n\nAssociated Code:  \n reg[31:0] cycles; \n reg[4:0] count; \n always @(posedge clk) \n begin \n  if(cycles < 2000000) \n  cycles <= cycles+1; \n  else begin \n  cycles <= 0; \n  count <= count+5'd1; \n  end \n  if(count == 5'd25-level) begin \n  count <= 0; \n  tick <= 1; \n  end \n  if(tick) \n  tick <= 0; \n  if(rst) begin \n  tick <= 0; \n  count <= 0; \n  cycles <= 0; \n  end \n end \n endmodule"}
{"task_id": "m2014_q4f", "detail_description": "Implement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.Use the following description and code as an example:\nDescription: \n\nThis Verilog module, omsp_and_gate, implements a 2-input AND gate. It takes two input signals, a and b, and generates an output signal y that represents the logical AND of inputs a and b.\n\n Module header:\n\nmodule omsp_and_gate (y,a,b);\n [/INST]\n\nAssociated Code:  \n output y; \n input a; \n input b; \n assign y = a & b; \n endmodule "}
{"task_id": "m2014_q4h", "detail_description": "The module assigns the output port to the same value as the input port combinationally.Use the following description and code as an example:\nDescription: \n\nThis Verilog module takes a 16-bit input and adds 1 to it. The result is then assigned to the output port.\n\n Module header:\n\nmodule plus_one(in, out);\n [/INST]\n\nAssociated Code:  \n  output [15:0] out; \n  input [15:0] in; \n  assign out = in + 16'd1; \n endmodule"}
{"task_id": "fsm1", "detail_description": "Consider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.Use the following description and code as an example:\nDescription: \n\nThis Verilog module is a Moore finite state machine (FSM) with two input bits and one output bit. The module transitions between seven states based on the input and current state, and the output yout changes accordingly. The states and state transitions are defined with case statements and the output yout is assigned in each state based on the current state. The module operates on clock and reset signals and uses sequential and combinational logic to implement the state machine.\n\n Module header:\n\nmodule Moore_FSM(input clk,input reset,input [1:0] x,output reg yout);\n [/INST]\n\nAssociated Code:  \n  reg [2:0] state, nextState; \n  parameter s0 = 0, a0 = 1, a1 = 2, b0 = 3, b1 = 4, t0 = 5, t1 = 6; \n  always @(posedge clk or posedge reset) begin \n  if (reset) begin \n  state <= s0; \n  end \n  else begin \n  state <= nextState; \n  end \n  end \n  always @(x or state) begin \n  case (state) \n  s0: begin \n  case (x) \n  0: nextState <= s0; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  a0: begin \n  case (x) \n  0: nextState <= a1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  a1: begin \n  case (x) \n  0: nextState <= a1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  b0: begin \n  case (x) \n  0: nextState <= b1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  b1: begin \n  case (x) \n  0: nextState <= b1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  t0: begin \n  case (x) \n  0: nextState <= t1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  t1: begin \n  case (x) \n  0: nextState <= t1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  endcase \n  end \n  always @(state) begin \n  case (state) \n  s0, a1: yout <= 0; \n  a0, b0, t0: yout <= yout; \n  b1: yout <= 1; \n  t1: yout <= ~yout; \n  endcase \n  end \n endmodule"}
{"task_id": "dualedge", "detail_description": "A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a negative edge-triggered D flip-flop. It has an input d, a clock input clk, a reset input reset, and an output q. On the negative edge of clk or reset, the output q is initialized to 0 when reset is asserted, and it takes the value of the input d when the clock is on the negative edge and the reset is not asserted.\n\n Module header:\n\nmodule f9_NegEdgeClock(q, d, clk, reset);\n [/INST]\n\nAssociated Code:  \n input d, clk, reset; \n output reg q; \n always @(negedge clk or negedge reset) \n  if(!reset) \n  q <= 1'b0; \n  else \n  q <= d; \n endmodule"}
{"task_id": "xnorgate", "detail_description": "Create a module that implements an XNOR gate.Use the following description and code as an example:\nDescription: \n\nThis module XNOR implements the functionality of an XNOR gate, which takes two input signals A and B and produces an output Z. The output Z is the logical complement of the XOR operation between A and B, effectively performing an XNOR operation.\n\n Module header:\n\nmodule XNOR (A,B,Z);\n [/INST]\n\nAssociated Code:  \n  input A, B; \n  output Z; \n  assign Z = ~(A^B); \n endmodule"}
{"task_id": "mt2015_q4", "detail_description": "Module A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.Use the following description and code as an example:\nDescription: \n\nThis Verilog module has two 32-bit input signals, a and b, and two 32-bit output signals, x and y. It also has an internal signal e. The module operates on the rising edge of the sysclock. Depending on the condition (y > x), x and y are updated differently. If the condition is true, x is incremented by 1, y is incremented by 2, a is updated based on the result of (x - y) with additional bit manipulation, and b is updated to the value of (y - x). If the condition is false, x is incremented by 1, y is updated by adding 4, a is updated to the result of (y - x), and b is updated to the result of (x - y).\n\n Module header:\n\nmodule Module1(input wire sysclock,output reg [31:0] x,output reg [31:0] y);\n [/INST]\n\nAssociated Code:  \n reg [31:0] a; \n reg [31:0] b; \n wire e; \n IOB __IOB (sysclock, x, y[0], e); \n initial begin \n  a <= 32'd0; \n  b <= 32'd0; \n  x <= 32'd0; \n  y <= 32'd0; \n end \n always @ (posedge sysclock) begin \n  if (y > x) begin \n  x <= (x + 32'h1); \n  y <= (y + 32'h2); \n  a <= {16'd0,((((x - y))>>0)&16'hffff)}; \n  b <= (y - x); \n  end \n  else begin \n  x <= (x + 32'h1); \n  y <= (y + 32'h4); \n  a <= (y - x); \n  b <= (x - y); \n  end \n end \n endmodule"}
{"task_id": "rotate100", "detail_description": "Build a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a rotator circuit, which rotates the input data by a specified number of bits based on the control signal RotatorOp. When RotatorOp is '00', the input is shifted to the left, and when RotatorOp is '10', the input is shifted to the right. When RotatorOp is '11', the input is rotated to the right with the most significant bit being replicated to the least significant bit. The number of shifts or rotations is determined by the value in the input RotatorBitNum. The resulting rotated output is stored in RotatorOut.\n\n Module header:\n\nmodule Rotator(input[31:0] RotatorIn,input[4:0] RotatorBitNum,input[1:0] RotatorOp,output[31:0] RotatorOut);\n [/INST]\n\nAssociated Code:  \n assign RotatorOut = \n  {32{RotatorOp==2'b00}} & (RotatorIn[31:0] << {1'b0,RotatorBitNum[4:0]}) | \n  {32{RotatorOp==2'b10}} & ({32'h0,RotatorIn[31:0]} >> {1'b0,RotatorBitNum[4:0]}) | \n  {32{RotatorOp==2'b11}} & ({{32{RotatorIn[31]}}, RotatorIn[31:0]} >> {1'b0,RotatorBitNum[4:0]}) ; \n endmodule"}
{"task_id": "review2015_count1k", "detail_description": "Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a 16-bit counter with reset and preset functionality. It counts down on each clock cycle when enabled, and can be reset to zero or preset to a specific value. The Zero_o output is asserted when the counter reaches zero.\n\n Module header:\n\nmodule Counter_RV1_Timer (input Reset_n_i,input Clk_i,input Preset_i,input Enable_i,input[15:0] PresetVal_i,output Zero_o);\n [/INST]\n\nAssociated Code:  \n  localparam Width = 16; \n  reg [Width-1:0] Value; \n  always @(negedge Reset_n_i or posedge Clk_i) \n  begin \n  if (!Reset_n_i) \n  begin \n  Value <= 'd0; \n  end \n  else \n  begin \n  if (Preset_i) begin \n  Value <= PresetVal_i; \n  end else if (Enable_i) \n  begin \n  Value <= Value - 1'b1; \n  end \n  end \n  end \n  assign Zero_o = (Value == 0 ? 1'b1 : 1'b0); \n endmodule"}
{"task_id": "notgate", "detail_description": "Create a module that implements a NOT gate.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a simple NOT gate, which takes an input A and produces the logical negation of A at the output Y. The assign statement inverts the input A to produce the output Y.\n\n Module header:\n\nmodule \\$_NOT_ (A, Y);\n [/INST]\n\nAssociated Code:  \n input A; \n output Y; \n assign Y = ~A; \n endmodule"}
{"task_id": "fsm_onehot", "detail_description": "Given the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.Use the following description and code as an example:\nDescription: \n\nThis module implements a state machine with four sets of inputs (X0, X1, X2, X3) and outputs (Y0, Y1, Y2, Y3), as well as inputs for clock and reset, and an output next_out. The state machine updates the outputs based on the inputs and the next input signal.\n\n Module header:\n\nmodule DirSum_30916(clk, reset, next, next_out,X0, Y0,X1, Y1,X2, Y2,X3, Y3);\n [/INST]\n\nAssociated Code:  \n  output next_out; \n  input clk, reset, next; \n  reg [0:0] i5; \n  input [15:0] X0, \n  X1, \n  X2, \n  X3; \n  output [15:0] Y0, \n  Y1, \n  Y2, \n  Y3; \n  always @(posedge clk) begin \n  if (reset == 1) begin \n  i5 <= 0; \n  end \n  else begin \n  if (next == 1) \n  i5 <= 0; \n  else if (i5 == 1) \n  i5 <= 0; \n  else \n  i5 <= i5 + 1; \n  end \n  end \n codeBlock30740 codeBlockIsnt33270(.clk(clk), .reset(reset), .next_in(next), .next_out(next_out),.i5_in(i5),.X0_in(X0), .Y0(Y0),.X1_in(X1), .Y1(Y1),.X2_in(X2), .Y2(Y2),.X3_in(X3), .Y3(Y3)); \n endmodule"}
{"task_id": "ece241_2013_q7", "detail_description": "A JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~QoldUse the following description and code as an example:\nDescription: \n\nThe \"jsrflipfloptb\" module simulates a J-K flip-flop with a shift register. It includes clock and reset inputs, as well as outputs q and qbar. The flip-flop is implemented using the \"jsrflipflop\" module. The module generates a clock signal, initializes it, and also handles the reset. It then tests the functionality of the shift register and the flip-flop module by assigning different values to the shift register and checking the output q. It then displays the pass or fail condition based on the expected and actual output values.\n\n Module header:\n\nmodule jsrflipfloptb;\n [/INST]\n\nAssociated Code:  \n  wire q, qbar; \n  reg clk,rst; \n  reg [1:0] sr; \n  jsrflipflop jsrff(q,qbar,clk,rst,sr); \n  always #5 clk = ~clk; \n  initial \n  begin \n  clk = 1'b0; \n  rst = 1; # 10; rst = 0; #10; \n  $display(\"RSLT\\ts\\tr\\tq\\tqbar\"); \n  sr = 0; # 10; \n  if ( q === 1'b0 ) \n  $display (\"PASS\\t%d\\t%d\\t%d\\t%d\",sr[1],sr[0],q,qbar); \n  else \n  $display (\"FAIL\\t%d\\t%d\\t%d\\t%d\",sr[1],sr[0],q,qbar); \n  sr = 1; # 10; \n  if ( q === 1'b0 ) \n  $display (\"PASS\\t%d\\t%d\\t%d\\t%d\",sr[1],sr[0],q,qbar); \n  else \n  $display (\"FAIL\\t%d\\t%d\\t%d\\t%d\",sr[1],sr[0],q,qbar); \n  sr = 2; # 10; \n  if ( q === 1'b1 ) \n  $display (\"PASS\\t%d\\t%d\\t%d\\t%d\",sr[1],sr[0],q,qbar); \n  else \n  $display (\"FAIL\\t%d\\t%d\\t%d\\t%d\",sr[1],sr[0],q,qbar); \n  sr = 3; # 10; \n  if ( q === 1'bx ) \n  $display (\"PASS\\t%d\\t%d\\t%d\\t%d\",sr[1],sr[0],q,qbar); \n  else \n  $display (\"FAIL\\t%d\\t%d\\t%d\\t%d\",sr[1],sr[0],q,qbar); \n  end \n endmodule"}
{"task_id": "popcount3", "detail_description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.Use the following description and code as an example:\nDescription: \n\nThis module is designed to count the number of active inputs (func_rb0 to func_rb15) and output the count in binary through the four-bit vector oCOUNT. The count is computed by incrementing a temporary four-bit register, func_rb_tmp_count, by 1 for each active input. The count is then assigned to the output oCOUNT.\n\n Module header:\n\nmodule reservation_free_entry_count(input wire iINFO0,input wire iINFO1,input wire iINFO2,input wire iINFO3,input wire iINFO4,input wire iINFO5,input wire iINFO6,input wire iINFO7,input wire iINFO8,input wire iINFO9,input wire iINFO10,input wire iINFO11,input wire iINFO12,input wire iINFO13,input wire iINFO14,input wire iINFO15,output wire [3:0] oCOUNT);\n [/INST]\n\nAssociated Code:  \n assign oCOUNT = func_rb_free_count16(iINFO0, iINFO1, iINFO2, iINFO3,iINFO4, iINFO5, iINFO6, iINFO7,iINFO8, iINFO9, iINFO10, iINFO11,iINFO12, iINFO13, iINFO14, iINFO15); \n  function [3:0] func_rb_free_count16; \n  input func_rb0; \n  input func_rb1; \n  input func_rb2; \n  input func_rb3; \n  input func_rb4; \n  input func_rb5; \n  input func_rb6; \n  input func_rb7; \n  input func_rb8; \n  input func_rb9; \n  input func_rb10; \n  input func_rb11; \n  input func_rb12; \n  input func_rb13; \n  input func_rb14; \n  input func_rb15; \n  reg [3:0] func_rb_tmp_count; \n  begin \n  func_rb_tmp_count = 4'h0; \n  if(func_rb0)begin \n  func_rb_tmp_count = func_rb_tmp_count + 4'h1; \n  end \n  if(func_rb1)begin \n  func_rb_tmp_count = func_rb_tmp_count + 4'h1; \n  end \n  if(func_rb2)begin \n  func_rb_tmp_count = func_rb_tmp_count + 4'h1; \n  end \n  if(func_rb3)begin \n  func_rb_tmp_count = func_rb_tmp_count + 4'h1; \n  end \n  if(func_rb4)begin \n  func_rb_tmp_count = func_rb_tmp_count + 4'h1; \n  end \n  if(func_rb5)begin \n  func_rb_tmp_count = func_rb_tmp_count + 4'h1; \n  end \n  if(func_rb6)begin \n  func_rb_tmp_count = func_rb_tmp_count + 4'h1; \n  end \n  if(func_rb7)begin \n  func_rb_tmp_count = func_rb_tmp_count + 4'h1; \n  end \n  if(func_rb8)begin \n  func_rb_tmp_count = func_rb_tmp_count + 4'h1; \n  end \n  if(func_rb9)begin \n  func_rb_tmp_count = func_rb_tmp_count + 4'h1; \n  end \n  if(func_rb10)begin \n  func_rb_tmp_count = func_rb_tmp_count + 4'h1; \n  end \n  if(func_rb11)begin \n  func_rb_tmp_count = func_rb_tmp_count + 4'h1; \n  end \n  if(func_rb12)begin \n  func_rb_tmp_count = func_rb_tmp_count + 4'h1; \n  end \n  if(func_rb13)begin \n  func_rb_tmp_count = func_rb_tmp_count + 4'h1; \n  end \n  if(func_rb14)begin \n  func_rb_tmp_count = func_rb_tmp_count + 4'h1; \n  end \n  if(func_rb15)begin \n  func_rb_tmp_count = func_rb_tmp_count + 4'h1; \n  end \n  func_rb_free_count16 = func_rb_tmp_count; \n  end \n  endfunction \n endmodule"}
{"task_id": "vector5", "detail_description": "Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.Use the following description and code as an example:\nDescription: \n\nThis Verilog module `sameRecFN` compares two floating-point numbers `a` and `b` based on their exponent and significand. It extracts the top 4 bits of `a` and `b`, and based on the value of these top 4 bits, it checks for equality of the top 4 bits and certain bits of the significand. The result of the comparison is assigned to the output `out`.\n\n Module header:\n\nmodule sameRecFN#(parameter expWidth = 3, parameter sigWidth = 3) (input [(expWidth + sigWidth):0] a,input [(expWidth + sigWidth):0] b,output out);\n [/INST]\n\nAssociated Code:  \n  wire [3:0] top4A = a[(expWidth + sigWidth):(expWidth + sigWidth - 3)]; \n  wire [3:0] top4B = b[(expWidth + sigWidth):(expWidth + sigWidth - 3)]; \n  assign out = \n  (top4A[2:0] == 'b000) || (top4A[2:0] == 'b111) \n  ? (top4A == top4B) && (a[(sigWidth - 2):0] == b[(sigWidth - 2):0]) \n  : (top4A[2:0] == 'b110) ? (top4A == top4B) : (a == b); \n endmodule"}
{"task_id": "lemmings1", "detail_description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a finite state machine for a two-player game. It has various states such as P1_Move, P1_Status, P2_Move, P2_Status, Win, Tie, and Loss, and transitions between these states based on player moves and game outcomes. The module tracks player turns and game status using input and output signals.\n\n Module header:\n\nmodule Gato_FSM(clk,reset,state,p1_mm,p2_mm,p1_tie,p1_loss,p1_win,p2_tie,p2_loss,p2_win,verifica_status,turno_p1,turno_p2,win_game,loss_game,tie_game);\n [/INST]\n\nAssociated Code:  \n  input clk, reset; \n  input p1_mm, p2_mm; \n  input p1_tie, p1_loss, p1_win, p2_tie, p2_loss, p2_win; \n  output reg turno_p1, turno_p2; \n  output reg verifica_status; \n  output reg win_game, loss_game, tie_game; \n  output [3:0] state; \n  reg [3:0] state, nextState; \n  parameter P1_Move = 0; \n  parameter P1_Status = 1; \n  parameter P2_Move = 2; \n  parameter P2_Status = 3; \n  parameter Win = 4; \n  parameter Tie = 5; \n  parameter Loss = 6; \n  initial turno_p1 <= 1'b1; \n  initial turno_p2 <= 1'b0; \n  always @(posedge clk or posedge reset) \n  begin \n  if (reset) \n  state <= P1_Move; \n  else \n  state <= nextState; \n  end \n  always @(state or p1_mm or p2_mm or p1_win or p1_loss or p1_tie or p2_win or p2_loss or p2_tie) \n  begin \n  nextState = 3'bxxx; \n  case(state) \n  P1_Move: \n  begin \n  verifica_status <= 1'b0; \n  turno_p1 <= 1'b1; \n  turno_p2 <= 1'b0; \n  if (p1_mm == 1'b0) \n  nextState = P1_Move; \n  else if (p1_mm == 1'b1) \n  nextState = P1_Status; \n  end \n  P1_Status: \n  begin \n  verifica_status <= 1'b1; \n  turno_p1 <= 1'b0; \n  turno_p2 <= 1'b1; \n  if (p1_tie == 1'b1 & p1_loss == 1'b0 & p1_win == 1'b0) \n  nextState = Tie; \n  else if (p1_win == 1'b1 & p1_tie == 1'b0 & p1_loss == 1'b0) \n  nextState = Loss; \n  else if (p2_mm == 1'b0) \n  nextState = P2_Move; \n  end \n  P2_Move: \n  begin \n  verifica_status <= 1'b0; \n  turno_p1 <= 1'b0; \n  turno_p2 <= 1'b1; \n  if (p2_mm == 1'b0) \n  nextState = P2_Move; \n  else if (p2_mm == 1'b1) \n  nextState = P2_Status; \n  end \n  P2_Status: \n  begin \n  verifica_status <= 1'b1; \n  turno_p1 <= 1'b1; \n  turno_p2 <= 1'b0; \n  if (p2_tie == 1'b1 & p2_loss == 1'b0 & p2_win == 1'b0) \n  nextState = Tie; \n  else if (p2_win == 1'b1 & p2_tie == 1'b0 & p2_loss == 1'b0) \n  nextState = Win; \n  else if (p1_mm == 1'b0) \n  nextState = P1_Move; \n  end \n  Win: \n  begin \n  win_game <= 1'b1; \n  nextState = Win; \n  end \n  Tie: \n  begin \n  tie_game <= 1'b1; \n  nextState = Tie; \n  end \n  Loss: \n  begin \n  loss_game <= 1'b1; \n  nextState = Loss; \n  end \n  default: nextState = P1_Move; \n  endcase \n  end \n endmodule"}
{"task_id": "circuit1", "detail_description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \nUse the following description and code as an example:\nDescription: \n\nThis module is a behavioral description of a combinational logic circuit with inputs cx0 and cx1 and outputs bm0 through bm7. The outputs are assigned based on logic operations like AND, NOR, and inverters on the inputs and intermediate signals n1 and n2. The module uses basic logic gates like AND2X1, NOR2X1, OAI21X1, NAND2X1, and inverters to determine the outputs based on the input conditions.\n\n Module header:\n\nmodule bmu ( cx0, cx1, bm0, bm1, bm2, bm3, bm4, bm5, bm6, bm7 );\n [/INST]\n\nAssociated Code:  \n  output [1:0] bm0; \n  output [1:0] bm1; \n  output [1:0] bm2; \n  output [1:0] bm3; \n  output [1:0] bm4; \n  output [1:0] bm5; \n  output [1:0] bm6; \n  output [1:0] bm7; \n  input cx0, cx1; \n  wire bm2_1_, bm6_1_, n1, n2; \n  assign bm1[1] = bm2_1_; \n  assign bm2[1] = bm2_1_; \n  assign bm0[1] = bm3[1]; \n  assign bm0[0] = bm3[0]; \n  assign bm1[0] = bm3[0]; \n  assign bm2[0] = bm3[0]; \n  assign bm5[1] = bm6_1_; \n  assign bm6[1] = bm6_1_; \n  assign bm4[1] = bm7[1]; \n  assign bm4[0] = bm7[0]; \n  assign bm5[0] = bm7[0]; \n  assign bm6[0] = bm7[0]; \n  AND2X1 U31 ( .A(n1), .B(cx1), .Y(bm7[1]) ); \n  NOR2X1 U32 ( .A(cx1), .B(n1), .Y(bm6_1_) ); \n  INVX1 U33 ( .A(cx0), .Y(n1) ); \n  NOR2X1 U34 ( .A(bm3[1]), .B(bm3[0]), .Y(bm2_1_) ); \n  INVX1 U35 ( .A(bm7[0]), .Y(bm3[0]) ); \n  OAI21X1 U36 ( .A(cx1), .B(cx0), .C(n2), .Y(bm7[0]) ); \n  INVX1 U37 ( .A(n2), .Y(bm3[1]) ); \n  NAND2X1 U38 ( .A(cx0), .B(cx1), .Y(n2) ); \n endmodule"}
{"task_id": "7458", "detail_description": "The 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.Use the following description and code as an example:\nDescription: \n\nThe Verilog module is a digital circuit that manages input and output signals based on the given code. It has inputs for the clock, ready_downstream, reset, and process_input, as well as outputs for ready and process_output. It includes various registers and combinational logic to process the inputs and generate the required outputs. The outputs depend on the cycle count, output count, and process input, and utilize various bitwise operations and registers for managing the signals. The module is designed to perform specific operations based on the input signals and produce the appropriate output signals accordingly.\n\n Module header:\n\nmodule Underflow_Auint8_2_1__4_1__count76800_cycles288910_toosoonnil_UStrue(input CLK, input ready_downstream, output ready, input reset, input [64:0] process_input, output [64:0] process_output);\n [/INST]\n\nAssociated Code:  \n parameter INSTANCE_NAME=\"INST\"; \n parameter OUTPUT_COUNT=0; \n parameter INPUT_COUNT=0; \n  wire [31:0] cycleCount_GET_OUTPUT; \n  wire unnamedbinop8810USEDMULTIPLEbinop;assign unnamedbinop8810USEDMULTIPLEbinop = {((cycleCount_GET_OUTPUT)>((32'd288910)))}; \n  assign ready = {(ready_downstream||unnamedbinop8810USEDMULTIPLEbinop)}; \n  wire unnamedbinop8812USEDMULTIPLEbinop;assign unnamedbinop8812USEDMULTIPLEbinop = {({(ready_downstream||reset)}||unnamedbinop8810USEDMULTIPLEbinop)}; \n  wire [31:0] outputCount_GET_OUTPUT; \n  wire unnamedcast8804USEDMULTIPLEcast;assign unnamedcast8804USEDMULTIPLEcast = (process_input[64]); \n  wire unnamedunary8832USEDMULTIPLEunary;assign unnamedunary8832USEDMULTIPLEunary = {(~reset)}; \n  wire [31:0] outputCount_SETBY_OUTPUT; \n  wire [31:0] cycleCount_SETBY_OUTPUT; \n  assign process_output = {{({({(unnamedbinop8810USEDMULTIPLEbinop&&{((outputCount_GET_OUTPUT)<((32'd76800)))})}||{({(~unnamedbinop8810USEDMULTIPLEbinop)}&&unnamedcast8804USEDMULTIPLEcast)})}&&unnamedunary8832USEDMULTIPLEunary)},((unnamedbinop8810USEDMULTIPLEbinop)?((64'd3735928559)):((process_input[63:0])))}; \n  RegBy_incif_1uint32_CEtable__0x0759af78_CEtrue_initnil #(.INSTANCE_NAME({INSTANCE_NAME,\"_outputCount\"})) outputCount(.CLK(CLK), .set_valid(reset), .CE(unnamedbinop8812USEDMULTIPLEbinop), .set_inp((32'd0)), .setby_valid(unnamedunary8832USEDMULTIPLEunary), .setby_inp({(ready_downstream&&{(unnamedcast8804USEDMULTIPLEcast||unnamedbinop8810USEDMULTIPLEbinop)})}), .SETBY_OUTPUT(outputCount_SETBY_OUTPUT), .GET_OUTPUT(outputCount_GET_OUTPUT)); \n  RegBy_incif_1uint32_CEtable__0x0759af78_CEtrue_initnil #(.INSTANCE_NAME({INSTANCE_NAME,\"_cycleCount\"})) cycleCount(.CLK(CLK), .set_valid(reset), .CE((1'd1)), .set_inp((32'd0)), .setby_valid(unnamedunary8832USEDMULTIPLEunary), .setby_inp((1'd1)), .SETBY_OUTPUT(cycleCount_SETBY_OUTPUT), .GET_OUTPUT(cycleCount_GET_OUTPUT)); \n endmodule"}
{"task_id": "2014_q3c", "detail_description": "Given the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\nUse the following description and code as an example:\nDescription: \n\nThis Verilog module, named TwoInGrid, checks for two-in-a-row occurrences in a 3x3 grid of X and Y states. It uses instances of the TwoInRow module to check rows, columns, and diagonals for the two-in-a-row condition. The outputs of these checks are combined using bitwise OR operations to produce the final output \"cout\".\n\n Module header:\n\nmodule TwoInGrid(input [8:0] X_state,input [8:0] Y_state,output wire [8:0] cout);\n [/INST]\n\nAssociated Code:  \n  wire [8:0] rows, cols; \n  wire [2:0] diag1, diag2; \n  TwoInRow row1 (X_state[2:0], Y_state[2:0], rows[2:0]); \n  TwoInRow row2 (X_state[5:3], Y_state[5:3], rows[5:3]); \n  TwoInRow row3 (X_state[8:6], Y_state[8:6], rows[8:6]); \n  TwoInRow col1 ({X_state[2], X_state[5], X_state[8]}, {Y_state[2], Y_state[5], Y_state[8]}, {cols[2], cols[5], cols[8]}); \n  TwoInRow col2 ({X_state[1], X_state[4], X_state[7]}, {Y_state[1], Y_state[4], Y_state[7]}, {cols[1], cols[4], cols[7]}); \n  TwoInRow col3 ({X_state[0], X_state[3], X_state[6]}, {Y_state[0], Y_state[3], Y_state[6]}, {cols[0], cols[3], cols[6]}); \n  TwoInRow diagCheck1 ({X_state[8], X_state[4], X_state[0]}, {Y_state[8], Y_state[4], Y_state[0]}, diag1); \n  TwoInRow diagCheck2 ({X_state[6], X_state[4], X_state[2]}, {Y_state[6], Y_state[4], Y_state[2]}, diag2); \n  assign cout = rows | cols | \n  {diag1[2], 1'b0, 1'b0, 1'b0, diag1[1], 1'b0, 1'b0, 1'b0, diag1[0]} | \n  {1'b0, 1'b0, diag2[2], 1'b0, diag2[1], 1'b0, diag2[0], 1'b0, 1'b0}; \n endmodule"}
{"task_id": "m2014_q4e", "detail_description": "Implement a 2-input NOR gate.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a 2-input NOR gate. The output is the negation of the logical OR of the two input signals.\n\n Module header:\n\nmodule f7_TECH_NOR2(input [1:0] in, output out);\n [/INST]\n\nAssociated Code:  \n assign out = ~(|in); \n endmodule"}
{"task_id": "wire4", "detail_description": "Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.Use the following description and code as an example:\nDescription: \n\nThis module implements a 4-to-1 multiplexer, where the output Y is based on the select inputs S1 and S0. Depending on the combination of S1 and S0, the output Y will be connected to one of the four data inputs D0, D1, D2, or D3.\n\n Module header:\n\nmodule CC_MX4 (input D0, D1, D2, D3,input S0, S1,output Y);\n [/INST]\n\nAssociated Code:  \n  assign Y = S1 ? (S0 ? D3 : D2) : \n  (S0 ? D1 : D0); \n endmodule"}
{"task_id": "m2014_q4b", "detail_description": "Implement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a positive edge-triggered D flip-flop with an asynchronous reset. The output Q is set to 1 when the reset input R is high, and it takes on the value of the input D otherwise.\n\n Module header:\n\nmodule \\$_DFF_PP1_ (D, C, R, Q);\n [/INST]\n\nAssociated Code:  \n input D, C, R; \n output reg Q; \n always @(posedge C or posedge R) begin \n  if (R == 1) \n  Q <= 1; \n  else \n  Q <= D; \n end \n endmodule"}
{"task_id": "always_case", "detail_description": "Create a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a 128-to-4 multiplexer. It selects a 4-bit output based on a 5-bit input selection signal (sel). The output is determined by the selected input range according to the value of the selection signal. For example, if sel = 5'h00, the output will be in[3:0], if sel = 5'h01, the output will be in[7:4], and so on until sel = 5'h1f, which gives the output in[127:124].\n\n Module header:\n\nmodule sel128_4 (input [127:0] in,input [ 4:0] sel,output reg [ 3:0] out);\n [/INST]\n\nAssociated Code:  \n  always @(in or sel) \n  case (sel) \n  5'h00: out <= in[ 3: 0]; \n  5'h01: out <= in[ 7: 4]; \n  5'h02: out <= in[ 11: 8]; \n  5'h03: out <= in[ 15: 12]; \n  5'h04: out <= in[ 19: 16]; \n  5'h05: out <= in[ 23: 20]; \n  5'h06: out <= in[ 27: 24]; \n  5'h07: out <= in[ 31: 28]; \n  5'h08: out <= in[ 35: 32]; \n  5'h09: out <= in[ 39: 36]; \n  5'h0a: out <= in[ 43: 40]; \n  5'h0b: out <= in[ 47: 44]; \n  5'h0c: out <= in[ 51: 48]; \n  5'h0d: out <= in[ 55: 52]; \n  5'h0e: out <= in[ 59: 56]; \n  5'h0f: out <= in[ 63: 60]; \n  5'h10: out <= in[ 67: 64]; \n  5'h11: out <= in[ 71: 68]; \n  5'h12: out <= in[ 75: 72]; \n  5'h13: out <= in[ 79: 76]; \n  5'h14: out <= in[ 83: 80]; \n  5'h15: out <= in[ 87: 84]; \n  5'h16: out <= in[ 91: 88]; \n  5'h17: out <= in[ 95: 92]; \n  5'h18: out <= in[ 99: 96]; \n  5'h19: out <= in[103:100]; \n  5'h1a: out <= in[107:104]; \n  5'h1b: out <= in[111:108]; \n  5'h1c: out <= in[115:112]; \n  5'h1d: out <= in[119:116]; \n  5'h1e: out <= in[123:120]; \n  5'h1f: out <= in[127:124]; \n  endcase \n endmodule"}
{"task_id": "timer", "detail_description": "Implement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\nUse the following description and code as an example:\nDescription: \n\nThis module is an n-bit counter with configurable functionality. It can perform increment, decrement, Gray code, or LFSR operations based on the TYPE parameter. The counter operates on each clock cycle and can load a new value or enable/disable counting based on the load and en inputs. The carry and zero outputs indicate overflow and zero conditions, respectively.\n\n Module header:\n\nmodule oh_counter #(parameter DW = 32,parameter TYPE = \"INCREMENT\") (input clk,input in,input en,input load,input [DW-1:0] load_data,output [DW-1:0] count,output carry,output zero);\n [/INST]\n\nAssociated Code:  \n  reg [DW-1:0] count; \n  reg carry; \n  wire [DW-1:0] count_in; \n  wire carry_in; \n  generate \n  if(TYPE==\"INCREMENT\") \n  begin \n  assign {carry_in,count_in[DW-1:0]} = count[DW-1:0] + in; \n  end \n  else if(TYPE==\"DECREMENT\") \n  begin \n  assign count_in[DW-1:0] = count[DW-1:0] + in; \n  end \n  else if (TYPE==\"GRAY\") \n  begin \n  initial \n  $display (\"NOT IMPLEMENTED\"); \n  end \n  else if (TYPE==\"LFSR\") \n  begin \n  initial \n  $display (\"NOT IMPLEMENTED\"); \n  end \n  endgenerate \n  always @(posedge clk) \n  if(load) \n  begin \n  carry <= 1'b0; \n  count[DW-1:0] <= load_data[DW-1:0]; \n  end \n  else if (en) \n  begin \n  carry <= carry_in; \n  count[DW-1:0] <= count_in[DW-1:0]; \n  end \n  assign zero = ~(count[DW-1:0]); \n endmodule "}
{"task_id": "review2015_fsmseq", "detail_description": "Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a sequence detector finite state machine (FSM) that searches for a specific pattern in the input data stream. The FSM has seven states labeled S0 to S6 and transitions based on the input data_in. When the sequence is detected, the output data_out is set to 1, otherwise it is set to 0. The FSM transitions through the states based on the current state and the input data_in, and it resets to the initial state S0 on a reset signal.\n\n Module header:\n\nmodule sequence_detector_fsm(data_out, state, reset, data_in, clk);\n [/INST]\n\nAssociated Code:  \n output data_out; \n output reg [2:0] state; \n input reset, data_in, clk; \n parameter FOUND = 1'b1, \n  NOT_FOUND = 1'b0; \n parameter S0 = 3'd0, \n  S1 = 3'd1, \n  S2 = 3'd2, \n  S3 = 3'd3, \n  S4 = 3'd4, \n  S5 = 3'd5, \n  S6 = 3'd6; \n reg this_data_in; \n reg [2:0] next_state; \n always @(posedge clk or posedge reset) begin \n  if (reset) begin \n  state <= S0; \n  this_data_in <= 1'b0; \n  end else begin \n  state <= next_state; \n  this_data_in <= data_in; \n  end \n end \n assign data_out = (state == S6 ? FOUND : NOT_FOUND); \n always @(state, this_data_in) begin \n  case (state) \n  S0: next_state = (this_data_in ? S1 : S0); \n  S1: next_state = (this_data_in ? S1 : S2); \n  S2: next_state = (this_data_in ? S3 : S0); \n  S3: next_state = (this_data_in ? S1 : S4); \n  S4: next_state = (this_data_in ? S5 : S0); \n  S5: next_state = (this_data_in ? S6 : S4); \n  S6: next_state = (this_data_in ? S1 : S2); \n  default: next_state = S0; \n  endcase \n end \n endmodule"}
{"task_id": "dff8r", "detail_description": "Create 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a positive edge-triggered D flip-flop with asynchronous preset functionality. The output q is initialized to 0 and updates to 1 on the positive edge of the clock if the pre input is asserted; otherwise, it updates to the value of the d input on the positive edge of the clock.\n\n Module header:\n\nmodule my_dffs_clk_p (input d,clk,pre,output reg q);\n [/INST]\n\nAssociated Code:  \n  initial q <= 0; \n  always @(posedge clk) \n  if (pre) q <= 1'b1; \n  else q <= d; \n endmodule"}
{"task_id": "edgedetect2", "detail_description": "For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.Use the following description and code as an example:\nDescription: \n\nThis Verilog module is designed to detect an edge in the input data stream. It uses a counter to keep track of the number of consecutive clock cycles for which the input data remains unchanged. Once the counter reaches a certain value (13 in this case), it sets the \"edgeseen\" output to 1. Additionally, if the input data changes after the counter reaches 15, it also sets the \"edgeseen\" output to 1. The module includes a reset signal to initialize the internal state variables.\n\n Module header:\n\nmodule edgedet(clk, rstn, datain, edgeseen);\n [/INST]\n\nAssociated Code:  \n  input clk; \n  input rstn; \n  input datain; \n  output reg edgeseen; \n  reg lastdata; \n  reg [3:0] count; \n  always @(posedge clk or negedge rstn) begin \n  if(rstn == 0) begin \n  edgeseen <= 0; \n  lastdata <= 0; \n  count <= 4'b0000; \n  end else begin \n  edgeseen <= 0; \n  if(count < 15) begin \n  lastdata <= datain; \n  count <= count + 1'b1; \n  end \n  if(count == 13) begin \n  edgeseen <= 1; \n  end \n  if((count == 15) && (lastdata ^ datain)) begin \n  edgeseen <= 1; \n  lastdata <= datain; \n  end \n  end \n  end \n endmodule"}
{"task_id": "count1to10", "detail_description": "Make a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.Use the following description and code as an example:\nDescription: \n\nThis Verilog module 'PulseCounter' implements a 4-bit counter that increments by 1 whenever the input 'In' transitions from low to high. The counter is reset to 0 when the 'Reset' input is low. The output 'Out' reflects the current count value. The toggle signal is used to ensure that the counter is only incremented once per pulse.\n\n Module header:\n\nmodule PulseCounter(input Reset,input Clock,input In,output [3:0] Out);\n [/INST]\n\nAssociated Code:  \n reg [3:0] Counter; \n reg toggle; \n always @(posedge Clock, negedge Reset) begin \n  if ( Reset == 0 ) \n  Counter <= 4'b0000; \n  else begin \n  if ((In==1) & (toggle==0)) begin \n  Counter <= Counter + 1'b1; \n  toggle <= 1; \n  end \n  else if (In==0) begin \n  toggle <= 0; \n  end \n  end \n end \n assign Out = Counter; \n endmodule"}
{"task_id": "circuit9", "detail_description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               Use the following description and code as an example:\nDescription: \n\nThis Verilog module is a square wave generator that takes inputs for clock frequency, frequency, amplitude, offset, and duty cycle, and outputs a 12-bit square wave signal. The module updates the state based on the clock signal and calculates the period and duty load based on the input frequency and duty cycle. It then computes the square wave signal based on the state, offset, and amplitude, taking care to clip the output within the 12-bit range.\n\n Module header:\n\nmodule square(input clksamp,input[31:0] freq,input signed[16:0] amp,input signed[16:0] offset,input[9:0] duty,output[11:0] sq);\n [/INST]\n\nAssociated Code:  \n parameter SAMP_FREQ = 100_000_000; \n reg state = 1'b0; \n reg[15:0] period_counter = 16'b0; \n reg[15:0] duty_counter = 16'b0; \n wire[15:0] period_load = (SAMP_FREQ/freq); \n wire[15:0] duty_load = (period_load * duty) / 1000; \n reg[15:0] period_load_reg = 32'b0; \n reg[15:0] duty_load_reg = 32'b0; \n always @(posedge clksamp) begin \n  period_load_reg <= period_load; \n  duty_load_reg <= duty_load; \n  period_counter <= (period_load_reg != period_load) ? period_load_reg - 1 : (period_counter > 0) ? period_counter - 1 : period_load_reg - 1; \n  duty_counter <= (duty_load_reg != duty_load) ? duty_load_reg - 1 : (duty_counter > 0) ? duty_counter - 1 : (period_counter > 0) ? 0 : duty_load_reg - 1; \n  state <= (duty_counter == 0 && period_counter > 0) ? 0 : 1; \n end \n wire signed[16:0] preclip = state ? offset + amp : offset - amp; \n assign sq = (freq == 0 || amp == 0) ? offset > 4095 ? 4095 : offset : duty == 0 ? 0 : preclip > 4095 ? 4095 : preclip < 0 ? 0 : preclip; \n endmodule"}
{"task_id": "lfsr5", "detail_description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a Galois Linear Feedback Shift Register (LFSR). It generates a random bit based on the inputs and a clock signal. The module keeps track of the calibration status and the previous inputs. On the positive clock edge, it updates the counter, stores the previous calibration status and inputs, and determines the random bit based on the counter and calibration status. If there is a change in the calibration status or inputs, it generates a new random bit and resets the counter to 0. Otherwise, it shifts the existing random bits and generates new random bits based on the previous ones.\n\n Module header:\n\nmodule galois_lfsr (input clk,input calib_done,input [`NUM_USER_INPUTS-1:0] buf_inputs,output reg [`WORD_BITS-1:0] rnd);\n [/INST]\n\nAssociated Code:  \n  initial begin \n  rnd = 1; \n  end \n  reg [`WORD_BITS-1:0] counter = 0; \n  reg [`NUM_USER_INPUTS-1:0] prev_inputs = 0; \n  reg prev_calib_done = 0; \n  always @ (posedge clk) begin \n  counter <= counter + 1; \n  prev_calib_done <= calib_done; \n  prev_inputs <= buf_inputs; \n if ((calib_done && !prev_calib_done)|| buf_inputs != prev_inputs) begin \n  rnd <= rnd ^ counter; \n  counter <= 0; \n  end else begin \n  rnd[`WORD_BITS-1] <= rnd[0]; \n  rnd[`WORD_BITS-2] <= rnd[`WORD_BITS-1]; \n  rnd[`WORD_BITS-3] <= rnd[`WORD_BITS-2] ^ rnd[0]; \n  rnd[`WORD_BITS-4] <= rnd[`WORD_BITS-3] ^ rnd[0]; \n  rnd[`WORD_BITS-5] <= rnd[`WORD_BITS-4]; \n  rnd[`WORD_BITS-6] <= rnd[`WORD_BITS-5] ^ rnd[0]; \n  rnd[`WORD_BITS-7:0] <= rnd[`WORD_BITS-6:1]; \n  end \n  end \n endmodule"}
{"task_id": "bugs_addsubz", "detail_description": "The following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmoduleUse the following description and code as an example:\nDescription: \n\nThis Verilog module implements a 32-bit adder-subtractor with flags for zero, carry, negative, and overflow. The inputs A and B are added or subtracted based on the values of aluc1 and aluc0. The result is stored in Result, and flags Zero, Carry, Negative, and Overflow are set based on the result and input values.\n\n Module header:\n\nmodule addsub32(input [31:0] A,input [31:0] B,input aluc1,input aluc0,output [31:0]Result,output Zero,output Carry,output Nagative,output Overflow);\n [/INST]\n\nAssociated Code:  \n reg [31:0]Result_temp; \n reg Zero_temp; \n reg Carry_temp; \n reg Nagative_temp; \n reg Overflow_temp; \n assign Result = Result_temp; \n assign Zero = Zero_temp; \n assign Carry = Carry_temp; \n assign Overflow = Overflow_temp; \n assign Nagative = Nagative_temp; \n always @* begin \n  if( aluc1 == 0 && aluc0 == 0 )begin \n  Result_temp = A + B; \n  if( Result_temp == 0 ) \n  Zero_temp = 1; \n  else \n  Zero_temp = 0; \n  if ( Result_temp < A || Result_temp < B ) Carry_temp = 1; \n  else Carry_temp = 0; \n  Nagative_temp = 0; \n  Overflow_temp = 0; \n  end \n  else if( aluc1 == 1 && aluc0 == 0 )begin \n  Result_temp = A + B; \n  if( Result_temp[31] == 1 ) \n  Nagative_temp = 1; \n  else if( Result_temp[31] == 0 ) \n  Nagative_temp = 0; \n  Carry_temp=0; \n  if ( A[31] & ~B[31]) Overflow_temp = 0; \n  else if ( ~A[31] & B[31] ) Overflow_temp = 0; \n  else if ( A[31] & B[31] & Result_temp[31] ) Overflow_temp = 0; \n  else if ( ~A[31] & ~B[31] & ~Result_temp[31]) Overflow_temp = 0; \n  else begin \n  Overflow_temp = 1; \n  Result_temp = 0; \n  end \n  if( Result_temp == 0 ) \n  Zero_temp = 1; \n  else \n  Zero_temp = 0; \n  end \n  else if( aluc1 == 0 && aluc0 == 1 )begin \n  Result_temp = A - B; \n  if( Result_temp == 0 ) \n  Zero_temp = 1; \n  else \n  Zero_temp = 0; \n  if( A >= B ) \n  Carry_temp = 0; \n  else \n  Carry_temp = 1; \n  Nagative_temp = 0; \n  Overflow_temp = 0; \n  end \n  else if( aluc1 == 1 && aluc0 == 1 )begin \n  Result_temp = A - B; \n  Carry_temp = 0; \n  if ( A[31] & B[31]) Overflow_temp = 0; \n  else if ( ~A[31] & ~B[31] ) Overflow_temp= 0; \n  else if ( A[31] & ~B[31] & Result_temp[31] ) Overflow_temp = 0; \n  else if ( ~A[31] & B[31] & ~Result_temp[31] ) Overflow_temp = 0; \n  else begin \n  Overflow_temp = 1; \n  Result_temp = 0; \n  end \n  if( Result_temp == 0 ) \n  Zero_temp = 1; \n  else \n  Zero_temp = 0; \n  if( Result_temp[31] == 1 ) \n  Nagative_temp = 1; \n  else if( Result_temp[31] == 0 ) \n  Nagative_temp = 0; \n  end \n end \n endmodule"}
{"task_id": "m2014_q3", "detail_description": "Consider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a custom logic function for the inputs a, b, and d. It performs bitwise operations on the inputs, including multiplication and XOR operations, to generate the output d. The module also instantiates two submodules (ksm1 and ksm3) to perform additional custom logic operations on the inputs. The result is a complex combination of bitwise operations to compute the output d.\n\n Module header:\n\nmodule Sks13(a, b, d);\n [/INST]\n\nAssociated Code:  \n input wire [12:0] a; \n input wire [12:0] b; \n output wire [24:0] d; \n wire [10:0] m1; \n wire [12:0] m2; \n wire [12:0] m3; \n wire [6:0] ahl; \n wire [6:0] bhl; \n Sks7 ksm1(a[6:0], b[6:0], m2); \n assign m1 = a[12:7] * b[12:7]; \n assign ahl[5:0] = a[12:7] ^ a[5:0]; \n assign ahl[6] = a[6]; \n assign bhl[5:0] = b[12:7] ^ b[5:0]; \n assign bhl[6] = b[6]; \n Sks7 ksm3(ahl, bhl, m3); \n assign d[00] = m2[00]; \n assign d[01] = m2[01]; \n assign d[02] = m2[02]; \n assign d[03] = m2[03]; \n assign d[04] = m2[04]; \n assign d[05] = m2[05]; \n assign d[06] = m2[06]; \n assign d[07] = m2[07] ^ m1[00] ^ m2[00] ^ m3[00]; \n assign d[08] = m2[08] ^ m1[01] ^ m2[01] ^ m3[01]; \n assign d[09] = m2[09] ^ m1[02] ^ m2[02] ^ m3[02]; \n assign d[10] = m2[10] ^ m1[03] ^ m2[03] ^ m3[03]; \n assign d[11] = m2[11] ^ m1[04] ^ m2[04] ^ m3[04]; \n assign d[12] = m2[12] ^ m1[05] ^ m2[05] ^ m3[05]; \n assign d[13] = m1[06] ^ m2[06] ^ m3[06]; \n assign d[14] = m1[07] ^ m2[07] ^ m3[07] ^ m1[00]; \n assign d[15] = m1[08] ^ m2[08] ^ m3[08] ^ m1[01]; \n assign d[16] = m1[09] ^ m2[09] ^ m3[09] ^ m1[02]; \n assign d[17] = m1[10] ^ m2[10] ^ m3[10] ^ m1[03]; \n assign d[18] = m2[11] ^ m3[11] ^ m1[04]; \n assign d[19] = m2[12] ^ m3[12] ^ m1[05]; \n assign d[20] = m1[06]; \n assign d[21] = m1[07]; \n assign d[22] = m1[08]; \n assign d[23] = m1[09]; \n assign d[24] = m1[10]; \n endmodule"}
{"task_id": "bugs_case", "detail_description": "This combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.Use the following description and code as an example:\nDescription: \n\nThis Verilog module takes in a scan_ready signal and an 8-bit scan_code, and outputs an 8-bit ASCII value. It includes logic to handle keyup events and maps specific scan codes to corresponding ASCII values. The keyup logic sets the output ASCII to 0 when a keyup event is detected. The scan code mapping assigns specific ASCII values based on the input scan_code. If the input scan_code matches any of the defined cases, the corresponding ASCII value is assigned to the output. If no match is found, the output is set to 0.\n\n Module header:\n\nmodule ascii (input scan_ready,input [7:0] scan_code,output [7:0] ascii);\n [/INST]\n\nAssociated Code:  \n  reg [7:0] r_ascii; \n  assign ascii = r_ascii; \n  reg keyup = 0; \n  always @(posedge scan_ready) begin \n  if (scan_code == 8'hf0) begin \n  keyup <= 1; \n  end else begin \n  if (keyup) begin \n  keyup <= 0; \n  r_ascii <= 8'd0; \n  end else \n  case (scan_code) \n  8'h29: r_ascii <= 8'd32; \n  8'h45: r_ascii <= 8'd48; \n  8'h16: r_ascii <= 8'd49; \n  8'h1e: r_ascii <= 8'd50; \n  8'h26: r_ascii <= 8'd51; \n  8'h25: r_ascii <= 8'd52; \n  8'h2e: r_ascii <= 8'd53; \n  8'h36: r_ascii <= 8'd54; \n  8'h3d: r_ascii <= 8'd55; \n  8'h3e: r_ascii <= 8'd56; \n  8'h46: r_ascii <= 8'd57; \n  8'h1c: r_ascii <= 8'd97; \n  8'h32: r_ascii <= 8'd98; \n  8'h21: r_ascii <= 8'd99; \n  8'h23: r_ascii <= 8'd100; \n  8'h24: r_ascii <= 8'd101; \n  8'h2b: r_ascii <= 8'd102; \n  8'h34: r_ascii <= 8'd103; \n  8'h33: r_ascii <= 8'd104; \n  8'h43: r_ascii <= 8'd105; \n  8'h3b: r_ascii <= 8'd106; \n  8'h42: r_ascii <= 8'd107; \n  8'h4b: r_ascii <= 8'd108; \n  8'h3a: r_ascii <= 8'd109; \n  8'h31: r_ascii <= 8'd110; \n  8'h44: r_ascii <= 8'd111; \n  8'h4d: r_ascii <= 8'd112; \n  8'h15: r_ascii <= 8'd113; \n  8'h2d: r_ascii <= 8'd114; \n  8'h1b: r_ascii <= 8'd115; \n  8'h2c: r_ascii <= 8'd116; \n  8'h3c: r_ascii <= 8'd117; \n  8'h2a: r_ascii <= 8'd118; \n  8'h1d: r_ascii <= 8'd119; \n  8'h22: r_ascii <= 8'd120; \n  8'h35: r_ascii <= 8'd121; \n  8'h1a: r_ascii <= 8'd122; \n  default: r_ascii <= 8'd0; \n  endcase \n  end \n  end \n endmodule"}
{"task_id": "vectorr", "detail_description": "Given an 8-bit input vector [7:0], reverse its bit ordering.Use the following description and code as an example:\nDescription: \n\nThis Verilog module takes an 8-bit input and outputs the same 8 bits in reverse order. It uses a simple concatenation to reorder the bits and assign them to the output ports.\n\n Module header:\n\nmodule bit_reverse(input [7:0] in,output [7:0] out);\n [/INST]\n\nAssociated Code:  \n  assign out[7:0] = { in[0],in[1],in[2],in[3],in[4],in[5],in[6],in[7] }; \n endmodule"}
{"task_id": "kmap3", "detail_description": "Implement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |Use the following description and code as an example:\nDescription: \n\nThis module takes a 45-bit input and processes it to generate a 4-digit BCD output. It extracts specific portions of the input to determine the BCD values for each digit, based on certain conditions, and assigns these values to the output. The processing involves multiple comparisons to determine the appropriate BCD values for each digit of the output. The final output represents the 4-digit BCD equivalent of the input.\n\n Module header:\n\nmodule getID_4digits(input enable,input [44:0] digits45,output reg [15:0] iddecimal4);\n [/INST]\n\nAssociated Code:  \n  integer ID; \n  integer temp0, temp1; \n always @(posedge enable) begin \n  ID = digits45[16:1]; \n  if(ID>=9000) iddecimal4[15:12] = 9; \n  else if(ID>=8000) iddecimal4[15:12] = 8; \n  else if(ID>=7000) iddecimal4[15:12] = 7; \n  else if(ID>=6000) iddecimal4[15:12] = 6; \n  else if(ID>=5000) iddecimal4[15:12] = 5; \n  else if(ID>=4000) iddecimal4[15:12] = 4; \n  else if(ID>=3000) iddecimal4[15:12] = 3; \n  else if(ID>=2000) iddecimal4[15:12] = 2; \n  else if(ID>=1000) iddecimal4[15:12] = 1; \n  else iddecimal4[15:12] = 0; \n  temp0 = ID-(iddecimal4[15:12]*1000); \n  if(temp0>=900) iddecimal4[11:8] = 9; \n  else if(temp0>=800) iddecimal4[11:8] = 8; \n  else if(temp0>=700) iddecimal4[11:8] = 7; \n  else if(temp0>=600) iddecimal4[11:8] = 6; \n  else if(temp0>=500) iddecimal4[11:8] = 5; \n  else if(temp0>=400) iddecimal4[11:8] = 4; \n  else if(temp0>=300) iddecimal4[11:8] = 3; \n  else if(temp0>=200) iddecimal4[11:8] = 2; \n  else if(temp0>=100) iddecimal4[11:8] = 1; \n  else iddecimal4[11:8] = 0; \n  temp1 = temp0-(iddecimal4[11:8]*100); \n  if(temp1>=90) iddecimal4[7:4] = 9; \n  else if(temp1>=80) iddecimal4[7:4] = 8; \n  else if(temp1>=70) iddecimal4[7:4] = 7; \n  else if(temp1>=60) iddecimal4[7:4] = 6; \n  else if(temp1>=50) iddecimal4[7:4] = 5; \n  else if(temp1>=40) iddecimal4[7:4] = 4; \n  else if(temp1>=30) iddecimal4[7:4] = 3; \n  else if(temp1>=20) iddecimal4[7:4] = 2; \n  else if(temp1>=10) iddecimal4[7:4] = 1; \n  else iddecimal4[7:4] = 0; \n  iddecimal4[3:0] = temp1-(iddecimal4[7:4]*10); \n end \n endmodule"}
{"task_id": "review2015_shiftcount", "detail_description": "Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a priority encoder with 8 inputs. It detects the highest priority input with a 1 and outputs a 3-bit code indicating the position of the first occurrence of 1 in the input. The detect signal indicates whether any 1 is present in the input, and the out signal provides the 3-bit priority encoding. If no 1 is present in the input, the detect signal is deasserted, and the out signal is 000. If there are multiple 1s in the input, the out signal indicates the highest-priority 1.\n\n Module header:\n\nmodule priority_encoder8 (input [ 7 : 0 ] in,output reg detect,output reg [ 2 : 0 ] out);\n [/INST]\n\nAssociated Code:  \n  always @ (*) \n  casez(in) \n  default : {detect, out} = 4'b0000; \n  8'b00000001 : {detect, out} = 4'b1000; \n  8'b0000001? : {detect, out} = 4'b1001; \n  8'b000001?? : {detect, out} = 4'b1010; \n  8'b00001??? : {detect, out} = 4'b1011; \n  8'b0001???? : {detect, out} = 4'b1100; \n  8'b001????? : {detect, out} = 4'b1101; \n  8'b01?????? : {detect, out} = 4'b1110; \n  8'b1??????? : {detect, out} = 4'b1111; \n  endcase \n endmodule"}
{"task_id": "wire", "detail_description": "Create a module with one input and one output that behaves like a wire.Use the following description and code as an example:\nDescription: \n\nThis Verilog module 'onewire' simply connects the input 'W_IN' to the output 'W_OUT'. It is a simple wire module that forwards the input to the output.\n\n Module header:\n\nmodule onewire(input W_IN, output W_OUT);\n [/INST]\n\nAssociated Code:  \n  assign W_OUT = W_IN; \n endmodule"}
{"task_id": "review2015_fsmshift", "detail_description": "This module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.Use the following description and code as an example:\nDescription: \n\nThis module is a shift register-based First-In-First-Out (FIFO) memory with a configurable data width. It stores and retrieves data based on the control signals write_en, write_data, read_en, and clk. The full and empty signals indicate whether the FIFO is full or empty, respectively. The module utilizes shift registers to manage the data and valid bits. It includes a reset functionality to initialize the pointer and control registers. The shift register is implemented using an integer variable and an initial block to set the data and valid registers to 0. The main functionality is implemented in an always block sensitive to the positive edge of the clock, which handles the writing, reading, and shifting of the data and valid registers based on the control signals and the state of the FIFO.\n\n Module header:\n\nmodule srl_fifo_reg # (parameter WIDTH = 8) (input wire clk,input wire rst,input wire write_en,input wire [WIDTH-1:0] write_data,input wire read_en,output wire [WIDTH-1:0] read_data,output wire full,output wire empty);\n [/INST]\n\nAssociated Code:  \n reg [WIDTH-1:0] data_reg[1:0]; \n reg valid_reg[1:0]; \n reg ptr_reg = 0; \n reg full_reg = 0; \n assign read_data = data_reg[ptr_reg]; \n assign full = full_reg; \n assign empty = ~valid_reg[ptr_reg]; \n wire [WIDTH-1:0] data_reg_0 = data_reg[0]; \n wire [WIDTH-1:0] data_reg_1 = data_reg[1]; \n wire valid_reg_0 = valid_reg[0]; \n wire valid_reg_1 = valid_reg[1]; \n reg shift; \n integer i; \n initial begin \n  for (i = 0; i < 2; i = i + 1) begin \n  data_reg[i] <= 0; \n  valid_reg[i] <= 0; \n  end \n end \n always @(posedge clk) begin \n  if (rst) begin \n  ptr_reg <= 0; \n  end else begin \n  full_reg <= ~read_en & ~empty; \n  if (~full_reg) begin \n  data_reg[0] <= write_data; \n  valid_reg[0] <= write_en; \n  for (i = 0; i < 1; i = i + 1) begin \n  data_reg[i+1] <= data_reg[i]; \n  valid_reg[i+1] <= valid_reg[i]; \n  end \n  ptr_reg <= valid_reg[0]; \n  end \n  if (read_en) begin \n  ptr_reg <= 0; \n  end \n  end \n end \n endmodule"}
{"task_id": "count15", "detail_description": "Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a 16-bit counter with reset and preset functionality. It counts down on each clock cycle when enabled, and can be reset to zero or preset to a specific value. The Zero_o output is asserted when the counter reaches zero.\n\n Module header:\n\nmodule Counter_RV1_Timer (input Reset_n_i,input Clk_i,input Preset_i,input Enable_i,input[15:0] PresetVal_i,output Zero_o);\n [/INST]\n\nAssociated Code:  \n  localparam Width = 16; \n  reg [Width-1:0] Value; \n  always @(negedge Reset_n_i or posedge Clk_i) \n  begin \n  if (!Reset_n_i) \n  begin \n  Value <= 'd0; \n  end \n  else \n  begin \n  if (Preset_i) begin \n  Value <= PresetVal_i; \n  end else if (Enable_i) \n  begin \n  Value <= Value - 1'b1; \n  end \n  end \n  end \n  assign Zero_o = (Value == 0 ? 1'b1 : 1'b0); \n endmodule"}
{"task_id": "always_if", "detail_description": "Build a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a 2-to-1 multiplexer (MUX). Depending on the value of the sel input, the output O will be either equal to A or B. The module uses the assign statement to implement the MUX logic, where the output O is assigned the value of A when sel is low and the value of B when sel is high.\n\n Module header:\n\nmodule MUX(O,A,B,sel);\n [/INST]\n\nAssociated Code:  \n  input wire A,B; \n  output wire O; \n  input wire sel; \n  assign O = (~sel)*A + (sel&B); \n endmodule"}
{"task_id": "kmap1", "detail_description": "Implement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \nUse the following description and code as an example:\nDescription: \n\nThis Verilog module takes a 11-bit binary input and converts it to a 4-digit binary-coded decimal (BCD) representation. It does this by iteratively subtracting multiples of 1000, 100, 10, and 1 from the input to extract the thousands, hundreds, tens, and ones places, respectively. The module updates the respective BCD outputs based on the extracted values using a series of conditional statements and loops.\n\n Module header:\n\nmodule bin_to_bcd(input wire [10:0] bin,output reg [3:0] ones,output reg [3:0] tens,output reg [3:0] hundreds,output reg [3:0] thousands);\n [/INST]\n\nAssociated Code:  \n parameter THOU = 1000; \n parameter HUND = 100; \n parameter TENS = 10; \n parameter ONES = 1; \n reg [10:0] buffer; \n integer i; \n integer sub; \n always @ (*) \n begin \n  buffer = bin; \n  ones = 4'd0; \n  tens = 4'd0; \n  hundreds = 4'd0; \n  thousands = 4'd0; \n  sub = 0; \n  if(buffer >= THOU) begin \n  for(i = 0; i < 10; i = i + 1) begin \n  if(i*THOU < buffer) begin \n  sub = sub + 1; \n  end \n  end \n  if(buffer < sub*THOU) begin \n  sub = sub - 1; \n  end \n  buffer = buffer - sub*THOU; \n  thousands = sub; \n  end \n  sub = 0; \n  if(buffer >= HUND) begin \n  for(i = 0; i < 10; i = i + 1) begin \n  if(i*HUND < buffer) begin \n  sub = sub + 1; \n  end \n  end \n  if(buffer < sub*HUND) begin \n  sub = sub - 1; \n  end \n  buffer = buffer - sub*HUND; \n  hundreds = sub; \n  end \n  sub = 0; \n  if(buffer >= TENS) begin \n  for(i = 0; i < 10; i = i + 1) begin \n  if(i*TENS < buffer) begin \n  sub = sub + 1; \n  end \n  end \n  if(buffer < sub*TENS) begin \n  sub = sub - 1; \n  end \n  buffer = buffer - sub*TENS; \n  tens = sub; \n  end \n  sub = 0; \n  if(buffer >= ONES) begin \n  for(i = 0; i < 10; i = i + 1) begin \n  if(i*ONES < buffer) begin \n  sub = sub + 1; \n  end \n  end \n  if(buffer < sub) begin \n  sub = sub - 1; \n  end \n  buffer = buffer - sub; \n  ones = sub; \n  end \n end \n endmodule"}
{"task_id": "2013_q2afsm", "detail_description": "Consider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements an arbiter with two request inputs (req_0 and req_1) and two grant outputs (gnt_0 and gnt_1). It is driven by a finite state machine (FSM) with three states: IDLE, GNT0, and GNT1. The arbiter selects one of the requests based on their priorities and controls the grants accordingly. The state transition logic is combinational and the state update is synchronous with the positive edge of the clock signal. When a request is granted, the corresponding grant signal is set to 1 while the other grant signal is set to 0. If there is no request, both grant signals are set to 0.\n\n Module header:\n\nmodule arbiter (clock ,reset ,req_0 ,req_1 ,gnt_0 ,gnt_1);\n [/INST]\n\nAssociated Code:  \n input clock,reset,req_0,req_1; \n output gnt_0,gnt_1; \n wire clock,reset,req_0,req_1; \n reg gnt_0,gnt_1; \n parameter SIZE = 3 ; \n parameter IDLE = 3'b001,GNT0 = 3'b010,GNT1 = 3'b100 ; \n reg [SIZE-1:0] state ; \n reg [SIZE-1:0] next_state ; \n always @ (state or req_0 or req_1) \n begin : FSM_COMBO \n  next_state = 3'b000; \n  case(state) \n  IDLE : if (req_0 == 1'b1) begin \n  next_state = GNT0; \n  end else if (req_1 == 1'b1) begin \n  next_state= GNT1; \n  end else begin \n  next_state = IDLE; \n  end \n  GNT0 : if (req_0 == 1'b1) begin \n  next_state = GNT0; \n  end else begin \n  next_state = IDLE; \n  end \n  GNT1 : if (req_1 == 1'b1) begin \n  next_state = GNT1; \n  end else begin \n  next_state = IDLE; \n  end \n  default : next_state = IDLE; \n  endcase \n end \n always @ (posedge clock) \n begin : FSM_SEQ \n  if (reset == 1'b1) begin \n  state <= IDLE; \n  end else begin \n  state <= next_state; \n  end \n end \n always @ (state) \n begin : OUTPUT_LOGIC \n  case(state) \n  IDLE : begin \n  gnt_0 = 1'b0; \n  gnt_1 = 1'b0; \n  end \n  GNT0 : begin \n  gnt_0 = 1'b1; \n  gnt_1 = 1'b0; \n  end \n  GNT1 : begin \n  gnt_0 = 1'b0; \n  gnt_1 = 1'b1; \n  end \n  default : begin \n  gnt_0 = 1'b0; \n  gnt_1 = 1'b0; \n  end \n  endcase \n end \n endmodule "}
{"task_id": "count10", "detail_description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a 16-bit counter with reset and preset functionality. It counts down on each clock cycle when enabled, and can be reset to zero or preset to a specific value. The Zero_o output is asserted when the counter reaches zero.\n\n Module header:\n\nmodule Counter_RV1_Timer (input Reset_n_i,input Clk_i,input Preset_i,input Enable_i,input[15:0] PresetVal_i,output Zero_o);\n [/INST]\n\nAssociated Code:  \n  localparam Width = 16; \n  reg [Width-1:0] Value; \n  always @(negedge Reset_n_i or posedge Clk_i) \n  begin \n  if (!Reset_n_i) \n  begin \n  Value <= 'd0; \n  end \n  else \n  begin \n  if (Preset_i) begin \n  Value <= PresetVal_i; \n  end else if (Enable_i) \n  begin \n  Value <= Value - 1'b1; \n  end \n  end \n  end \n  assign Zero_o = (Value == 0 ? 1'b1 : 1'b0); \n endmodule"}
{"task_id": "fsm_ps2", "detail_description": "The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a state machine for receiving data from a PS2 mouse. It shifts in data from the ps2_data input and processes it based on ps2_clk_posedge, wait_for_incoming_data, and start_receiving_data inputs. It includes state transitions for idle, wait for data, data in, parity in, and stop in. It also handles data counting, shifting data into a register, and outputting the received data.\n\n Module header:\n\nmodule ps2_mouse_datain (input clk,input reset,input wait_for_incoming_data,input start_receiving_data,input ps2_clk_posedge,input ps2_clk_negedge,input ps2_data,output reg [7:0] received_data,output reg received_data_en);\n [/INST]\n\nAssociated Code:  \n  localparam PS2_STATE_0_IDLE = 3'h0, \n  PS2_STATE_1_WAIT_FOR_DATA = 3'h1, \n  PS2_STATE_2_DATA_IN = 3'h2, \n  PS2_STATE_3_PARITY_IN = 3'h3, \n  PS2_STATE_4_STOP_IN = 3'h4; \n  reg [3:0] data_count; \n  reg [7:0] data_shift_reg; \n  reg [2:0] ns_ps2_receiver; \n  reg [2:0] s_ps2_receiver; \n  always @(posedge clk) begin \n  if (reset == 1'b1) s_ps2_receiver <= PS2_STATE_0_IDLE; \n  else s_ps2_receiver <= ns_ps2_receiver; \n  end \n  always @(*) begin \n  ns_ps2_receiver = PS2_STATE_0_IDLE; \n  case (s_ps2_receiver) \n  PS2_STATE_0_IDLE: \n  begin \n  if((wait_for_incoming_data == 1'b1) && (received_data_en == 1'b0)) \n  ns_ps2_receiver = PS2_STATE_1_WAIT_FOR_DATA; \n  else if ((start_receiving_data == 1'b1) && (received_data_en == 1'b0)) \n  ns_ps2_receiver = PS2_STATE_2_DATA_IN; \n  else ns_ps2_receiver = PS2_STATE_0_IDLE; \n  end \n  PS2_STATE_1_WAIT_FOR_DATA: \n  begin \n  if((ps2_data == 1'b0) && (ps2_clk_posedge == 1'b1)) \n  ns_ps2_receiver = PS2_STATE_2_DATA_IN; \n  else if (wait_for_incoming_data == 1'b0) \n  ns_ps2_receiver = PS2_STATE_0_IDLE; \n  else \n  ns_ps2_receiver = PS2_STATE_1_WAIT_FOR_DATA; \n  end \n  PS2_STATE_2_DATA_IN: \n  begin \n  if((data_count == 3'h7) && (ps2_clk_posedge == 1'b1)) \n  ns_ps2_receiver = PS2_STATE_3_PARITY_IN; \n  else \n  ns_ps2_receiver = PS2_STATE_2_DATA_IN; \n  end \n  PS2_STATE_3_PARITY_IN: \n  begin \n  if (ps2_clk_posedge == 1'b1) \n  ns_ps2_receiver = PS2_STATE_4_STOP_IN; \n  else \n  ns_ps2_receiver = PS2_STATE_3_PARITY_IN; \n  end \n  PS2_STATE_4_STOP_IN: \n  begin \n  if (ps2_clk_posedge == 1'b1) \n  ns_ps2_receiver = PS2_STATE_0_IDLE; \n  else \n  ns_ps2_receiver = PS2_STATE_4_STOP_IN; \n  end \n  default: \n  begin \n  ns_ps2_receiver = PS2_STATE_0_IDLE; \n  end \n  endcase \n  end \n  always @(posedge clk) begin \n  if (reset == 1'b1) data_count <= 3'h0; \n  else if((s_ps2_receiver == PS2_STATE_2_DATA_IN) && (ps2_clk_posedge == 1'b1)) \n  data_count <= data_count + 3'h1; \n  else if(s_ps2_receiver != PS2_STATE_2_DATA_IN) \n  data_count <= 3'h0; \n  end \n  always @(posedge clk) begin \n  if(reset == 1'b1) data_shift_reg <= 8'h00; \n  else if((s_ps2_receiver == PS2_STATE_2_DATA_IN) && (ps2_clk_posedge == 1'b1)) \n  data_shift_reg <= {ps2_data, data_shift_reg[7:1]}; \n  end \n  always @(posedge clk) begin \n  if(reset == 1'b1) received_data <= 8'h00; \n  else if(s_ps2_receiver == PS2_STATE_4_STOP_IN) \n  received_data <= data_shift_reg; \n  end \n  always @(posedge clk) begin \n  if(reset == 1'b1) received_data_en <= 1'b0; \n  else if((s_ps2_receiver == PS2_STATE_4_STOP_IN) && (ps2_clk_posedge == 1'b1)) \n  received_data_en <= 1'b1; \n  else \n  received_data_en <= 1'b0; \n  end \n endmodule"}
{"task_id": "mux2to1", "detail_description": "Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a 2-to-1 multiplexer with inputs a_in and b_in, a select signal sel, and an output out. The output is selected based on the value of sel - if sel is 0, the output is a_in, and if sel is 1, the output is b_in. The module has a parameter called width, which sets the bit width of the inputs and outputs. If sel has any other value, the output is set to 0.\n\n Module header:\n\nmodule mult_2_to_1(sel, a_in, b_in, out);\n [/INST]\n\nAssociated Code:  \n  parameter width = 'd16; \n  input wire sel; \n  input wire [width-1:0] a_in, b_in; \n  output reg [width-1:0] out; \n  always@(sel, a_in, b_in) begin \n  case(sel) \n  1'b0: out [width-1:0] = a_in [width-1:0]; \n  1'b1: out [width-1:0] = b_in [width-1:0]; \n  default: out [width-1:0] = {width{1'b0}}; \n  endcase \n  end \n endmodule"}
{"task_id": "gates4", "detail_description": "Build a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\nUse the following description and code as an example:\nDescription: \n\nThis Verilog module, XOR4, takes four input signals A, B, C, and D, and computes the bitwise XOR operation on them. The result is then assigned to the output signal Y.\n\n Module header:\n\nmodule XOR4 (input A, B, C, D,output Y);\n [/INST]\n\nAssociated Code:  \n  assign Y = A ^ B ^ C ^ D; \n endmodule"}
{"task_id": "2014_q3bfsm", "detail_description": "Given the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\nUse the following description and code as an example:\nDescription: \n\nThis Verilog module implements a 2-bit finite state machine (FSMup) with states s0, s1, s2, and s3, which transitions based on the input 'in'. The state transitions and the output 'out' are determined by the input and the current state. The FSMup module also has clock and reset inputs, and a synchronous reset is applied when the reset signal is asserted. The state transitions and the output are determined based on the input and the current state.\n\n Module header:\n\nmodule FSMup(clk, rst, in, out );\n [/INST]\n\nAssociated Code:  \n  input clk, rst; \n  input in; \n  output reg [1:0] out; \n  wire w, w2; \n  assign w2 = in; \n  reg [1:0] state, nextstate; \n  parameter [1:0] s0 = 2'b00, s1 = 2'b01, s2 = 2'b10, s3 = 2'b11; \n  always @ (w2 or state ) \n  if(w2 == 2'b0) nextstate = state; \n  else \n  case (state) \n  s0: \n  begin \n  if(w2) begin nextstate = s1; out <= 2'b00; end \n  end \n  s1: \n  begin \n  if (w2) begin nextstate = s2; out<= 2'b01;end \n  end \n  s2: \n  begin \n  if (w2) begin nextstate = s3; out<= 2'b10;end \n  end \n  s3: \n  begin \n  if (w2) begin nextstate = s0; out <= 2'b11;end \n  end \n  default: begin \n  nextstate = 2'bx; \n  end \n  endcase \n  always @ (posedge clk or posedge rst) \n  begin \n  if (rst) begin state <= s0; end \n  else state <= nextstate; \n  end \n endmodule"}
{"task_id": "2013_q2bfsm", "detail_description": "Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a finite state machine (FSM) that handles four requests and grants them based on the priority. The module has inputs for the clock, reset, and four request signals, and outputs for the four grant signals.\n\nThe FSM has four states: IDLE, GNT0, GNT1, and GNT2. The module uses a case statement to transition between states based on the requests and resets the grants accordingly. When a request is received, the FSM transitions to the corresponding grant state and sets the grant signal to 1. When the request is de-asserted, the FSM transitions back to the IDLE state and resets the grant signal to 0.\n\nThe module is sensitive to the clock edge and updates the state and grant signals accordingly. When the reset is asserted, all grant signals are set to 0, and the FSM transitions to the IDLE state.\n\n Module header:\n\nmodule fsm_full(clock ,reset ,req_0 ,req_1 ,req_2 ,req_3 ,gnt_0 ,gnt_1 ,gnt_2 ,gnt_3);\n [/INST]\n\nAssociated Code:  \n input clock ; \n input reset ; \n input req_0 ; \n input req_1 ; \n input req_2 ; \n input req_3 ; \n output gnt_0 ; \n output gnt_1 ; \n output gnt_2 ; \n output gnt_3 ; \n reg gnt_0 ; \n reg gnt_1 ; \n reg gnt_2 ; \n reg gnt_3 ; \n parameter [2:0] IDLE = 3'b000; \n parameter [2:0] GNT0 = 3'b001; \n parameter [2:0] GNT1 = 3'b010; \n parameter [2:0] GNT2 = 3'b011; \n parameter [2:0] GNT3 = 3'b100; \n reg [2:0] state, next_state; \n always @ (state or req_0 or req_1 or req_2 or req_3) \n begin \n  next_state = 0; \n  case(state) \n  IDLE : if (req_0 == 1'b1) begin \n  next_state = GNT0; \n  end else if (req_1 == 1'b1) begin \n  next_state= GNT1; \n  end else if (req_2 == 1'b1) begin \n  next_state= GNT2; \n  end else if (req_3 == 1'b1) begin \n  next_state= GNT3; \n  end else begin \n  next_state = IDLE; \n  end \n  GNT0 : if (req_0 == 1'b0) begin \n  next_state = IDLE; \n  end else begin \n  next_state = GNT0; \n  end \n  GNT1 : if (req_1 == 1'b0) begin \n  next_state = IDLE; \n  end else begin \n  next_state = GNT1; \n  end \n  GNT2 : if (req_2 == 1'b0) begin \n  next_state = IDLE; \n  end else begin \n  next_state = GNT2; \n  end \n  GNT3 : if (req_3 == 1'b0) begin \n  next_state = IDLE; \n  end else begin \n  next_state = GNT3; \n  end \n  default : next_state = IDLE; \n  endcase \n end \n always @ (posedge clock) \n begin : OUTPUT_LOGIC \n  if (reset) begin \n  gnt_0 <= 1'b0; \n  gnt_1 <= 1'b0; \n  gnt_2 <= 1'b0; \n  gnt_3 <= 1'b0; \n  state <= IDLE; \n  end else begin \n  state <= next_state; \n  case(state) \n  IDLE : begin \n  gnt_0 <= 1'b0; \n  gnt_1 <= 1'b0; \n  gnt_2 <= 1'b0; \n  gnt_3 <= 1'b0; \n  end \n  GNT0 : begin \n  gnt_0 <= 1'b1; \n  end \n  GNT1 : begin \n  gnt_1 <= 1'b1; \n  end \n  GNT2 : begin \n  gnt_2 <= 1'b1; \n  end \n  GNT3 : begin \n  gnt_3 <= 1'b1; \n  end \n  default : begin \n  state <= IDLE; \n  end \n  endcase \n  end \n end \n endmodule"}
{"task_id": "dff8p", "detail_description": "Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.Use the following description and code as an example:\nDescription: \n\nThis Verilog module is a general-purpose D flip-flop with synchronous active-low reset functionality. It has an input D, clock CLK, active-low reset nSET, and output nQ. The parameter INIT has a default value of 1'bx, and it initializes nQ to the value of INIT. The behavior is defined using an always block that triggers on the positive edge of CLK and the negative edge of nSET. When nSET is low, nQ is set to 1'b0, and if nSET is high, nQ is set to the complement of D.\n\n Module header:\n\nmodule GP_DFFSI(input D, CLK, nSET, output reg nQ);\n [/INST]\n\nAssociated Code:  \n  parameter [0:0] INIT = 1'bx; \n  initial nQ = INIT; \n  always @(posedge CLK, negedge nSET) begin \n  if (!nSET) \n  nQ <= 1'b0; \n  else \n  nQ <= ~D; \n  end \n endmodule"}
{"task_id": "reduction", "detail_description": "Parity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.Use the following description and code as an example:\nDescription: \n\nThis module is an encoder that takes an input data vector of length DATA_BITS and outputs a data vector with added parity bits. It also outputs the parity bit vector. The data is valid when Data_valid_08p is asserted. The module includes logic to handle resets and computes the parity based on the input data. The encoding process involves computing parity bits for the input data and combining them with the original data to produce the output data with parity. The module is implemented using a combination of logic gates and sequential elements.\n\n Module header:\n\nmodule Encoder #(parameter DATA_BITS = 128, PARITY_BITS = 9) (Data_in_08p, Data_valid_08p,reset_b, clk,Data_out_10p, Parity_out_10p);\n [/INST]\n\nAssociated Code:  \n  parameter k = DATA_BITS; \n  parameter r = PARITY_BITS; \n  input wire clk, reset_b, Data_valid_08p; \n  input wire [k:1] Data_in_08p; \n  output reg [k:1] Data_out_10p; \n  output reg [r:1] Parity_out_10p; \n  reg [k:1] Data; \n  reg [r:1] Parity; \n  reg data_valid_int; \n  always @(posedge clk or negedge reset_b) begin \n  if(~reset_b) begin \n  Data <= 'd0; \n  data_valid_int <= 'd0; \n  Data_out_10p <= 'd0; \n  Parity_out_10p <= 'd0; \n  end \n  else if(Data_valid_08p) begin \n  data_valid_int <= Data_valid_08p; \n  Data <= Data_in_08p; \n  if(data_valid_int) begin \n  Data_out_10p <= Data; \n  Parity_out_10p <= Parity; \n  end \n  end \n  end \n  reg [k+r-1:1] data_parity_i; \n  integer i,j,l,cnt; \n  reg a; \n  always @(Data) begin \n  j = 1; l = 1; \n  while ( (j<k+r) || (l<=k)) begin \n  if ( j == ((~j+1)&j)) begin \n  data_parity_i[j] = 1'b0; \n  j = j+1; \n  end \n  else begin \n  data_parity_i[j] = Data[l]; \n  j = j+1; l = l+1; \n  end \n  end \n  for(i=1;i<r;i=i+1) begin \n  cnt = 1; \n  a = cnt[i-1] & data_parity_i[1]; \n  for(cnt=2;cnt<(k+r);cnt=cnt+1) begin \n  a = a ^ (data_parity_i[cnt] & cnt[i-1]); \n  end \n  Parity[i] = a; \n  end \n  Parity[r] = (^Parity[r-1:1])^(^data_parity_i); \n  end \n endmodule"}
{"task_id": "fsm3comb", "detail_description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1Use the following description and code as an example:\nDescription: \n\nThis Verilog module is a Moore state machine that generates outputs a and b based on the input signals clk, rst_n, and enb. The module has five states: IN_FINAL, IN_IDLE, IN_INITIAL, IN_SEQ1, and IN_SEQ2. It uses real data type for a_1, b_1, a_reg, and b_reg, and updates their values based on the current state and input signals. The outputs a and b are assigned the converted real values of a_1 and b_1. The module transitions between states based on the current state, and updates the next state and the registers a_reg_next and b_reg_next accordingly.\n\n Module header:\n\nmodule Moore_Chart (clk,rst_n,enb,a,b);\n [/INST]\n\nAssociated Code:  \n  input clk; \n  input rst_n; \n  input enb; \n  output [63:0] a; \n  output [63:0] b; \n  parameter IN_FINAL = 3'd0, IN_IDLE = 3'd1, IN_INITIAL = 3'd2, IN_SEQ1 = 3'd3, IN_SEQ2 = 3'd4; \n  reg [2:0] is_Moore_Chart; \n  real a_1; \n  real b_1; \n  real a_reg; \n  real b_reg; \n  reg [2:0] is_Moore_Chart_next; \n  real a_reg_next; \n  real b_reg_next; \n  always @(posedge clk or negedge rst_n) \n  begin : Moore_Chart_1_process \n  if (rst_n == 1'b0) begin \n  is_Moore_Chart <= IN_INITIAL; \n  end \n  else begin \n  if (enb) begin \n  is_Moore_Chart <= is_Moore_Chart_next; \n  a_reg <= a_reg_next; \n  b_reg <= b_reg_next; \n  end \n  end \n  end \n  always @* begin \n  is_Moore_Chart_next = is_Moore_Chart; \n  a_reg_next = a_reg; \n  b_reg_next = b_reg; \n  case ( is_Moore_Chart) \n  IN_FINAL : \n  begin \n  end \n  IN_IDLE : \n  begin \n  a_reg_next = 0.0; \n  end \n  IN_INITIAL : \n  begin \n  a_reg_next = 0.0; \n  b_reg_next = 0.0; \n  end \n  IN_SEQ1 : \n  begin \n  a_reg_next = 1.0; \n  b_reg_next = b_reg + 1.0; \n  end \n  endcase \n  case ( is_Moore_Chart) \n  IN_FINAL : \n  begin \n  is_Moore_Chart_next = IN_IDLE; \n  end \n  IN_IDLE : \n  begin \n  is_Moore_Chart_next = IN_SEQ1; \n  end \n  IN_INITIAL : \n  begin \n  is_Moore_Chart_next = IN_IDLE; \n  end \n  IN_SEQ1 : \n  begin \n  is_Moore_Chart_next = IN_SEQ2; \n  end \n  default : \n  begin \n  is_Moore_Chart_next = IN_FINAL; \n  end \n  endcase \n  end \n  always @* a_1 = a_reg_next; \n  always @* b_1 = b_reg_next; \n  assign a = $realtobits(a_1); \n  assign b = $realtobits(b_1); \n endmodule "}
{"task_id": "mt2015_q4b", "detail_description": "The module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               Use the following description and code as an example:\nDescription: \n\nThis Verilog module is a square wave generator that takes inputs for clock frequency, frequency, amplitude, offset, and duty cycle, and outputs a 12-bit square wave signal. The module updates the state based on the clock signal and calculates the period and duty load based on the input frequency and duty cycle. It then computes the square wave signal based on the state, offset, and amplitude, taking care to clip the output within the 12-bit range.\n\n Module header:\n\nmodule square(input clksamp,input[31:0] freq,input signed[16:0] amp,input signed[16:0] offset,input[9:0] duty,output[11:0] sq);\n [/INST]\n\nAssociated Code:  \n parameter SAMP_FREQ = 100_000_000; \n reg state = 1'b0; \n reg[15:0] period_counter = 16'b0; \n reg[15:0] duty_counter = 16'b0; \n wire[15:0] period_load = (SAMP_FREQ/freq); \n wire[15:0] duty_load = (period_load * duty) / 1000; \n reg[15:0] period_load_reg = 32'b0; \n reg[15:0] duty_load_reg = 32'b0; \n always @(posedge clksamp) begin \n  period_load_reg <= period_load; \n  duty_load_reg <= duty_load; \n  period_counter <= (period_load_reg != period_load) ? period_load_reg - 1 : (period_counter > 0) ? period_counter - 1 : period_load_reg - 1; \n  duty_counter <= (duty_load_reg != duty_load) ? duty_load_reg - 1 : (duty_counter > 0) ? duty_counter - 1 : (period_counter > 0) ? 0 : duty_load_reg - 1; \n  state <= (duty_counter == 0 && period_counter > 0) ? 0 : 1; \n end \n wire signed[16:0] preclip = state ? offset + amp : offset - amp; \n assign sq = (freq == 0 || amp == 0) ? offset > 4095 ? 4095 : offset : duty == 0 ? 0 : preclip > 4095 ? 4095 : preclip < 0 ? 0 : preclip; \n endmodule"}
{"task_id": "2012_q2fsm", "detail_description": "Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a finite state machine that responds to different input conditions. The state machine has three states - rx_got_null, rx_got_nchar, and rx_got_time_code, with transitions based on the inputs last_is_data, last_is_timec, and last_is_control. The outputs rx_got_null, rx_got_nchar, and rx_got_time_code are set based on the input conditions, determining the current state of the state machine. The module also includes a reset condition to initialize the state machine.\n\n Module header:\n\nmodule rx_buffer_fsm (input posedge_clk,input rx_resetn,input last_is_data,input last_is_timec,input last_is_control,output reg rx_got_null,output reg rx_got_nchar,output reg rx_got_time_code);\n [/INST]\n\nAssociated Code:  \n always@(posedge posedge_clk or negedge rx_resetn) \n begin \n  if(!rx_resetn) \n  begin \n  rx_got_null <= 1'b0; \n  rx_got_nchar <= 1'b0; \n  rx_got_time_code <= 1'b0; \n  end \n  else \n  begin \n  if(last_is_data == 1'b1 ) \n  begin \n  rx_got_null <= 1'b0; \n  rx_got_nchar <= 1'b1; \n  rx_got_time_code <= 1'b0; \n  end \n  else if(last_is_timec == 1'b1) \n  begin \n  rx_got_null <= 1'b0; \n  rx_got_nchar <= 1'b0; \n  rx_got_time_code <= 1'b1; \n  end \n  else if(last_is_control == 1'b1) \n  begin \n  rx_got_null <= 1'b1; \n  rx_got_nchar <= 1'b0; \n  rx_got_time_code <= 1'b0; \n  end \n  else \n  begin \n  rx_got_null <= 1'b0; \n  rx_got_nchar <= 1'b0; \n  rx_got_time_code <= 1'b0; \n  end \n  end \n end \n endmodule"}
{"task_id": "dff16e", "detail_description": "Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a 9-bit register for a game, where each bit is controlled by a separate input. The inputs are synchronized to a common clock and can be cleared individually. The clear signals for each register are controlled by the corresponding clear inputs when the reset signal is not active. When the reset signal is active, all clear signals are set to 1, effectively resetting the register.\n\n Module header:\n\nmodule Registro_Juego(clk,reset_in,c1_clear_in,c2_clear_in,c3_clear_in,c4_clear_in,c5_clear_in,c6_clear_in,c7_clear_in,c8_clear_in,c9_clear_in,c1_in,c2_in,c3_in,c4_in,c5_in,c6_in,c7_in,c8_in,c9_in,c1_out,c2_out,c3_out,c4_out,c5_out,c6_out,c7_out,c8_out,c9_out);\n [/INST]\n\nAssociated Code:  \n  input clk,reset_in; \n  input c1_clear_in, c2_clear_in, c3_clear_in, c4_clear_in, c5_clear_in, c6_clear_in, c7_clear_in, c8_clear_in, c9_clear_in; \n  input [1:0] c1_in, c2_in, c3_in, c4_in, c5_in, c6_in, c7_in, c8_in, c9_in; \n  output [1:0] c1_out, c2_out, c3_out, c4_out, c5_out, c6_out, c7_out, c8_out, c9_out; \n  reg clear_c1, clear_c2, clear_c3, clear_c4, clear_c5, clear_c6, clear_c7, clear_c8, clear_c9; \n Registro2Bits espacio_1 (.clk(clk),.datos_i (c1_in),.clear_i(c1_clear_in),.salida_o(c1_out)); \n Registro2Bits espacio_2 (.clk(clk),.datos_i (c2_in),.clear_i(c2_clear_in),.salida_o(c2_out)); \n Registro2Bits espacio_3 (.clk(clk),.datos_i (c3_in),.clear_i(c3_clear_in),.salida_o(c3_out)); \n Registro2Bits espacio_4 (.clk(clk),.datos_i (c4_in),.clear_i(c4_clear_in),.salida_o(c4_out)); \n Registro2Bits espacio_5 (.clk(clk),.datos_i (c5_in),.clear_i(c5_clear_in),.salida_o(c5_out)); \n Registro2Bits espacio_6 (.clk(clk),.datos_i (c6_in),.clear_i(c6_clear_in),.salida_o(c6_out)); \n Registro2Bits espacio_7 (.clk(clk),.datos_i (c7_in),.clear_i(c7_clear_in),.salida_o(c7_out)); \n Registro2Bits espacio_8 (.clk(clk),.datos_i (c8_in),.clear_i(c8_clear_in),.salida_o(c8_out)); \n Registro2Bits espacio_9 (.clk(clk),.datos_i (c9_in),.clear_i(c9_clear_in),.salida_o(c9_out)); \n  always @( posedge clk or posedge reset_in) begin \n  if(reset_in) \n  begin \n  clear_c1 <= 1; \n  clear_c2 <= 1; \n  clear_c3 <= 1; \n  clear_c4 <= 1; \n  clear_c5 <= 1; \n  clear_c6 <= 1; \n  clear_c7 <= 1; \n  clear_c8 <= 1; \n  clear_c9 <= 1; \n  end \n  else \n  begin \n  clear_c1 <= c1_clear_in; \n  clear_c2 <= c2_clear_in; \n  clear_c3 <= c3_clear_in; \n  clear_c4 <= c4_clear_in; \n  clear_c5 <= c5_clear_in; \n  clear_c6 <= c6_clear_in; \n  clear_c7 <= c7_clear_in; \n  clear_c8 <= c8_clear_in; \n  clear_c9 <= c9_clear_in; \n  end \n  end \n endmodule"}
{"task_id": "edgedetect", "detail_description": "For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a logic function for edge detection based on input signals. It calculates thresholds for high, low, and zero transitions, and determines if the input signal crosses these thresholds. It then generates an edge state and edge toggle signal based on the transitions and trigger conditions. The module operates on the positive edge of the clock signal and updates its internal registers accordingly.\n\n Module header:\n\nmodule lf_edge_detect(input clk, input [7:0] adc_d, input [7:0] lf_ed_threshold,output [7:0] max, output [7:0] min,output [7:0] high_threshold, output [7:0] highz_threshold,output [7:0] lowz_threshold, output [7:0] low_threshold,output edge_state, output edge_toggle);\n [/INST]\n\nAssociated Code:  \n  min_max_tracker tracker(clk, adc_d, lf_ed_threshold, min, max); \n  assign high_threshold = (max + min) / 2 + (max - min) / 4; \n  assign highz_threshold = (max + min) / 2 + (max - min) / 8; \n  assign lowz_threshold = (max + min) / 2 - (max - min) / 8; \n  assign low_threshold = (max + min) / 2 - (max - min) / 4; \n  wire enabled = \n  (high_threshold > highz_threshold) \n  & (highz_threshold > lowz_threshold) \n  & (lowz_threshold > low_threshold) \n  & ((high_threshold - highz_threshold) > 8) \n  & ((highz_threshold - lowz_threshold) > 16) \n  & ((lowz_threshold - low_threshold) > 8); \n  reg is_high = 0; \n  reg is_low = 0; \n  reg is_zero = 0; \n  reg trigger_enabled = 1; \n  reg output_edge = 0; \n  reg output_state; \n  always @(posedge clk) \n  begin \n  is_high <= (adc_d >= high_threshold); \n  is_low <= (adc_d <= low_threshold); \n  is_zero <= ((adc_d > lowz_threshold) & (adc_d < highz_threshold)); \n  end \n  always @(posedge clk) \n  if (enabled) begin \n  if (trigger_enabled & (is_high | is_low)) begin \n  output_edge <= ~output_edge; \n  trigger_enabled <= 0; \n  end else \n  trigger_enabled <= trigger_enabled | is_zero; \n  end \n  always @(posedge clk) \n  if (enabled) begin \n  if (is_high) \n  output_state <= 1'd1; \n  else if (is_low) \n  output_state <= 1'd0; \n  end \n  assign edge_state = output_state; \n  assign edge_toggle = output_edge; \n endmodule"}
{"task_id": "circuit8", "detail_description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       Use the following description and code as an example:\nDescription: \n\nThis module is a circuit that operates on a clock signal and a data input to produce a quantum output. It uses several internal registers to maintain state information. The behavior of the module is controlled by clock edges and the data input. The output q is dependent on the current state and the data input, and the state is updated based on the data input and the value of another internal register. The module also includes initialization with random values if `RANDOM_INIT` is defined.\n\n Module header:\n\nmodule pext_p2_4 ( clk, d, q );\n [/INST]\n\nAssociated Code:  \n  input clk; \n  input d; \n  output q; \n  reg q; \n  reg c_q; \n  reg [1:0] r_cnt; \n  reg [1:0] c_cnt; \n  reg [1:0] cig_zerocnt; \n `ifdef RANDOM_INIT \n  initial begin \n  $random_init(\"q\", \"r_cnt\"); \n  end \n `endif \n  always @(posedge clk) begin \n  r_cnt <= \n  (^c_cnt === 1'bx) ? $random : \n  c_cnt; \n  q <= c_q; \n  end \n  always @ (d or q or r_cnt) begin \n  cig_zerocnt = 2'b0; \n  c_cnt = d ? ~cig_zerocnt : {r_cnt - ((|r_cnt) ? 2'b1 : 2'b0)}; \n  c_q = d | (|r_cnt); \n  end \n endmodule"}
{"task_id": "rule90", "detail_description": "Rule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).Use the following description and code as an example:\nDescription: \n\nThis Verilog module is an implementation of the Conway's Game of Life cellular automaton. It takes an input grid of states and applies the rules of the game to calculate the next state of each cell. The output grid of states represents the next generation of the game. The module defines the grid size using parameters WIDTH and HEIGHT. It initializes the boundary cells to zero, and for the inner cells, it calculates the sum of neighboring cell states to determine the next state using the rules of the Game of Life.\n\n Module header:\n\nmodule conway #(parameter WIDTH = 32,parameter HEIGHT = 32)(in_states,out_states);\n [/INST]\n\nAssociated Code:  \n  input [WIDTH*HEIGHT-1:0] in_states; \n  output [WIDTH*HEIGHT-1:0] out_states; \n  genvar r, c; \n  generate \n  for (c = 0; c < WIDTH; c=c+1) begin \n  assign out_states[c] = 0; \n  assign out_states[(HEIGHT-1)*WIDTH + c] = 0; \n  end \n  for (r = 1; r < HEIGHT-1; r=r+1) begin \n  assign out_states[r * WIDTH] = 0; \n  assign out_states[(r + 1) * WIDTH - 1] = 0; \n  for (c = 1; c < WIDTH-1; c=c+1) begin \n  wire cur_state_i; \n  wire [4:0] sum_i; \n  assign cur_state_i = in_states[r * WIDTH + c]; \n  assign sum_i = in_states[r * WIDTH + c-WIDTH-1] + in_states[r * WIDTH + c-WIDTH] + in_states[r * WIDTH + c-WIDTH+1] + in_states[r * WIDTH + c-1] + in_states[r * WIDTH + c+1] + in_states[r * WIDTH + c+WIDTH-1] + in_states[r * WIDTH + c+WIDTH] + in_states[r * WIDTH + c+WIDTH+1]; \n  wire eq2_i, eq3_i; \n  assign eq2_i = (sum_i == 2); \n  assign eq3_i = (sum_i == 3); \n  wire next_state_i; \n  assign next_state_i = (cur_state_i & (eq2_i | eq3_i)) | (~cur_state_i & eq3_i); \n  assign out_states[r * WIDTH + c] = next_state_i; \n  end \n  end \n  endgenerate \n endmodule"}
{"task_id": "mt2015_eq2", "detail_description": "Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a 2-to-1 multiplexer. It takes two 16-bit inputs A and B, and one select input S. The output MO is assigned the value of B when S is 1, and the value of A when S is 0.\n\n Module header:\n\nmodule cyclonev_bmux21 (MO, A, B, S);\n [/INST]\n\nAssociated Code:  \n  input [15:0] A, B; \n  input S; \n  output [15:0] MO; \n  assign MO = (S == 1) ? B : A; \n endmodule"}
{"task_id": "gatesv100", "detail_description": "You are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\nUse the following description and code as an example:\nDescription: \n\nThis Verilog module compares the bits of two 8-bit input vectors 'a' and 'b'. It uses a for loop to iterate through each bit position and performs a bitwise XOR operation between the corresponding bits of 'a' and 'b'. The result of this XOR operation is then inverted and stored in the 'match' output vector, effectively indicating which bits in 'a' and 'b' are matching.\n\n Module header:\n\nmodule match_bits_v(input [7:0] a,b, output reg [7:0] match);\n [/INST]\n\nAssociated Code:  \n  integer i; \n  wire ab_xor; \n  always @(a or b) begin \n  for (i=7; i>=0; i=i-1) begin \n  match[i] = ~(a[i]^b[i]); \n  end \n  end \n endmodule"}
{"task_id": "m2014_q4a", "detail_description": "Implement a D latch using an always block.\nUse the following description and code as an example:\nDescription: \n\nThis Verilog module implements a D-latch with an enable input E and a reset input R. When R is 0, the output Q is set to 1, and when E is 0, the output Q is set to the value of the input D.\n\n Module header:\n\nmodule \\$_DLATCH_NN1_ (E, R, D, Q);\n [/INST]\n\nAssociated Code:  \n input E, R, D; \n output reg Q; \n always @* begin \n  if (R == 0) \n  Q <= 1; \n  else if (E == 0) \n  Q <= D; \n end \n endmodule"}
{"task_id": "mux256to1v", "detail_description": "Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a 16-to-1 multiplexer. It selects one of the 16 input bits based on the 4-bit selection vector S and assigns the selected bit to the output Y.\n\n Module header:\n\nmodule mux16 (D,S,Y);\n [/INST]\n\nAssociated Code:  \n  input [15:0] D; \n  input [3:0] S; \n  output Y; \n  assign Y = D[S]; \n endmodule"}
{"task_id": "mux9to1v", "detail_description": "Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a 16-to-1 multiplexer. It selects one of the 16 input bits based on the 4-bit selection vector S and assigns the selected bit to the output Y.\n\n Module header:\n\nmodule mux16 (D,S,Y);\n [/INST]\n\nAssociated Code:  \n  input [15:0] D; \n  input [3:0] S; \n  output Y; \n  assign Y = D[S]; \n endmodule"}
{"task_id": "vectorgates", "detail_description": "Build a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a 9-bit selector that selects between two 9-bit input vectors a and b, and outputs the result based on a 9-bit control signal. It achieves this by concatenating the input vectors, sending them through a 18-bit round-robin arbiter (RARb), and then performing a bitwise OR operation to select the 9 most significant bits from the concatenated vector.\n\n Module header:\n\nmodule Select2(input [8:0] a,input [8:0] b,output wire [8:0] out);\n [/INST]\n\nAssociated Code:  \n  wire [17:0] x; \n  RARb #(18) ra({a, b}, x); \n  assign out = x[17:9] | x[8:0]; \n endmodule"}
{"task_id": "fsm3onehot", "detail_description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1Use the following description and code as an example:\nDescription: \n\nThis Verilog module is a Moore state machine that generates outputs a and b based on the input signals clk, rst_n, and enb. The module has five states: IN_FINAL, IN_IDLE, IN_INITIAL, IN_SEQ1, and IN_SEQ2. It uses real data type for a_1, b_1, a_reg, and b_reg, and updates their values based on the current state and input signals. The outputs a and b are assigned the converted real values of a_1 and b_1. The module transitions between states based on the current state, and updates the next state and the registers a_reg_next and b_reg_next accordingly.\n\n Module header:\n\nmodule Moore_Chart (clk,rst_n,enb,a,b);\n [/INST]\n\nAssociated Code:  \n  input clk; \n  input rst_n; \n  input enb; \n  output [63:0] a; \n  output [63:0] b; \n  parameter IN_FINAL = 3'd0, IN_IDLE = 3'd1, IN_INITIAL = 3'd2, IN_SEQ1 = 3'd3, IN_SEQ2 = 3'd4; \n  reg [2:0] is_Moore_Chart; \n  real a_1; \n  real b_1; \n  real a_reg; \n  real b_reg; \n  reg [2:0] is_Moore_Chart_next; \n  real a_reg_next; \n  real b_reg_next; \n  always @(posedge clk or negedge rst_n) \n  begin : Moore_Chart_1_process \n  if (rst_n == 1'b0) begin \n  is_Moore_Chart <= IN_INITIAL; \n  end \n  else begin \n  if (enb) begin \n  is_Moore_Chart <= is_Moore_Chart_next; \n  a_reg <= a_reg_next; \n  b_reg <= b_reg_next; \n  end \n  end \n  end \n  always @* begin \n  is_Moore_Chart_next = is_Moore_Chart; \n  a_reg_next = a_reg; \n  b_reg_next = b_reg; \n  case ( is_Moore_Chart) \n  IN_FINAL : \n  begin \n  end \n  IN_IDLE : \n  begin \n  a_reg_next = 0.0; \n  end \n  IN_INITIAL : \n  begin \n  a_reg_next = 0.0; \n  b_reg_next = 0.0; \n  end \n  IN_SEQ1 : \n  begin \n  a_reg_next = 1.0; \n  b_reg_next = b_reg + 1.0; \n  end \n  endcase \n  case ( is_Moore_Chart) \n  IN_FINAL : \n  begin \n  is_Moore_Chart_next = IN_IDLE; \n  end \n  IN_IDLE : \n  begin \n  is_Moore_Chart_next = IN_SEQ1; \n  end \n  IN_INITIAL : \n  begin \n  is_Moore_Chart_next = IN_IDLE; \n  end \n  IN_SEQ1 : \n  begin \n  is_Moore_Chart_next = IN_SEQ2; \n  end \n  default : \n  begin \n  is_Moore_Chart_next = IN_FINAL; \n  end \n  endcase \n  end \n  always @* a_1 = a_reg_next; \n  always @* b_1 = b_reg_next; \n  assign a = $realtobits(a_1); \n  assign b = $realtobits(b_1); \n endmodule "}
{"task_id": "conditional", "detail_description": "Given four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). Use the following description and code as an example:\nDescription: \n\nThis Verilog module compares the two input numbers a and b and the carry-in (cin) to determine if a is less than b. It has parameters for the widths of a and b, and for representing the numbers in signed or unsigned form. It handles signed representation by two's complementing the numbers and comparing them. The module outputs the result of the comparison as o.\n\n Module header:\n\nmodule oper_less_than (a, b, cin, o);\n [/INST]\n\nAssociated Code:  \n  parameter width_a = 6; \n  parameter width_b = 6; \n  parameter sgate_representation = 0; \n  parameter width_max= width_a>width_b ? width_a : width_b; \n  input [width_a-1:0] a; \n  input [width_b-1:0] b; \n  input cin; \n  output o; \n  integer sa; \n  integer sb; \n  reg [width_a-1:0] not_a; \n  reg [width_b-1:0] not_b; \n  reg tmp_result; \n  initial \n  begin \n  if (width_a <= 0) \n  begin \n  $display(\"Error! width_a must be greater than 0.\\n\"); \n  $display (\"Time: %0t Instance: %m\", $time); \n  end \n  if (width_b <= 0) \n  begin \n  $display(\"Error! width_b must be greater than 0.\\n\"); \n  $display (\"Time: %0t Instance: %m\", $time); \n  end \n  if (sgate_representation != 1 && sgate_representation != 0) \n  begin \n  $display(\"Error! sgate_representation value must be 1 (SIGNED) or 0 (UNSIGNED).\"); \n  $display (\"Time: %0t Instance: %m\", $time); \n  end \n  end \n  always @(a or b or cin) \n  begin \n  sa = a; \n  sb = b; \n  not_a = ~a; \n  not_b = ~b; \n  if (sgate_representation == \"SIGNED\") \n  begin \n  if (a[width_a-1] == 1) \n  sa = (not_a) * (-1) - 1; \n  if (b[width_b-1] == 1) \n  sb = (not_b) * (-1) - 1; \n  if (sa<sb) \n  begin \n  tmp_result = 1; \n  end \n  else if ((sa==sb)&&(cin)) \n  begin \n  tmp_result = 1; \n  end \n  else \n  begin \n  tmp_result = 0; \n  end \n  end \n  else \n  begin \n  if (a<b) \n  begin \n  tmp_result = 1; \n  end \n  else if ((a==b)&&(cin)) \n  begin \n  tmp_result = 1; \n  end \n  else \n  begin \n  tmp_result = 0; \n  end \n  end \n  end \n  assign o = tmp_result; \n endmodule "}
{"task_id": "gates", "detail_description": "Build a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not bUse the following description and code as an example:\nDescription: \n\nThis Verilog module implements a 6-bit partial full-fledged multiplexer gate. It takes two 6-bit inputs, i_a and i_b, and produces an 11-bit output o_r. The logic for each bit of the output is determined by a combination of AND and XOR operations between the corresponding bits of i_a and i_b.\n\n Module header:\n\nmodule d_partial_FFM_gate_6b (input wire [5:0] i_a,input wire [5:0] i_b,output wire [10:0] o_r);\n [/INST]\n\nAssociated Code:  \n  assign o_r[10] = (i_a[5]&i_b[5]); \n  assign o_r[ 9] = (i_a[4]&i_b[5]) ^ (i_a[5]&i_b[4]); \n  assign o_r[ 8] = (i_a[3]&i_b[5]) ^ (i_a[4]&i_b[4]) ^ (i_a[5]&i_b[3]); \n  assign o_r[ 7] = (i_a[2]&i_b[5]) ^ (i_a[3]&i_b[4]) ^ (i_a[4]&i_b[3]) ^ (i_a[5]&i_b[2]); \n  assign o_r[ 6] = (i_a[1]&i_b[5]) ^ (i_a[2]&i_b[4]) ^ (i_a[3]&i_b[3]) ^ (i_a[4]&i_b[2]) ^ (i_a[5]&i_b[1]); \n  assign o_r[ 5] = (i_a[0]&i_b[5]) ^ (i_a[1]&i_b[4]) ^ (i_a[2]&i_b[3]) ^ (i_a[3]&i_b[2]) ^ (i_a[4]&i_b[1]) ^ (i_a[5]&i_b[0]); \n  assign o_r[ 4] = (i_a[0]&i_b[4]) ^ (i_a[1]&i_b[3]) ^ (i_a[2]&i_b[2]) ^ (i_a[3]&i_b[1]) ^ (i_a[4]&i_b[0]); \n  assign o_r[ 3] = (i_a[0]&i_b[3]) ^ (i_a[1]&i_b[2]) ^ (i_a[2]&i_b[1]) ^ (i_a[3]&i_b[0]); \n  assign o_r[ 2] = (i_a[0]&i_b[2]) ^ (i_a[1]&i_b[1]) ^ (i_a[2]&i_b[0]); \n  assign o_r[ 1] = (i_a[0]&i_b[1]) ^ (i_a[1]&i_b[0]); \n  assign o_r[ 0] = (i_a[0]&i_b[0]); \n endmodule"}
{"task_id": "kmap2", "detail_description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |Use the following description and code as an example:\nDescription: \n\nThis module implements a combinational circuit that takes a 12-bit input and produces a 12-bit output based on multiple XOR operations on specific bits of the input. The output bits are assigned based on different combinations of the input bits, resulting in a specific output value for each bit index.\n\n Module header:\n\nmodule d_SC_evaluation_matrix_018(i_in, o_out);\n [/INST]\n\nAssociated Code:  \n  input wire [11:0] i_in; \n  output wire [`D_SC_GF_ORDER-1:0] o_out; \n  assign o_out[0] = i_in[0] ^ i_in[4] ^ i_in[5] ^ i_in[6] ^ i_in[10]; \n  assign o_out[1] = i_in[1] ^ i_in[2] ^ i_in[3] ^ i_in[4] ^ i_in[5] ^ i_in[9] ^ i_in[10] ^ i_in[11]; \n  assign o_out[2] = i_in[2] ^ i_in[4] ^ i_in[5] ^ i_in[9] ^ i_in[10] ^ i_in[11]; \n  assign o_out[3] = i_in[2] ^ i_in[3] ^ i_in[5] ^ i_in[6] ^ i_in[7] ^ i_in[10]; \n  assign o_out[4] = i_in[1] ^ i_in[3] ^ i_in[4] ^ i_in[6] ^ i_in[7] ^ i_in[9] ^ i_in[10] ^ i_in[11]; \n  assign o_out[5] = i_in[1] ^ i_in[2] ^ i_in[4] ^ i_in[5] ^ i_in[7] ^ i_in[9] ^ i_in[10] ^ i_in[11]; \n  assign o_out[6] = i_in[1] ^ i_in[4] ^ i_in[5] ^ i_in[6] ^ i_in[7] ^ i_in[8] ^ i_in[9] ^ i_in[10]; \n  assign o_out[7] = i_in[6] ^ i_in[9]; \n  assign o_out[8] = i_in[1] ^ i_in[5] ^ i_in[7] ^ i_in[8] ^ i_in[9] ^ i_in[10]; \n  assign o_out[9] = i_in[1] ^ i_in[2] ^ i_in[3] ^ i_in[4] ^ i_in[5] ^ i_in[6] ^ i_in[8] ^ i_in[10] ^ i_in[11]; \n  assign o_out[10] = i_in[1] ^ i_in[2] ^ i_in[4] ^ i_in[5] ^ i_in[7] ^ i_in[10] ^ i_in[11]; \n  assign o_out[11] = i_in[3] ^ i_in[4] ^ i_in[8]; \n endmodule"}
{"task_id": "2014_q3fsm", "detail_description": "Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a 2-bit finite state machine (FSMup) with states s0, s1, s2, and s3, which transitions based on the input 'in'. The state transitions and the output 'out' are determined by the input and the current state. The FSMup module also has clock and reset inputs, and a synchronous reset is applied when the reset signal is asserted. The state transitions and the output are determined based on the input and the current state.\n\n Module header:\n\nmodule FSMup(clk, rst, in, out );\n [/INST]\n\nAssociated Code:  \n  input clk, rst; \n  input in; \n  output reg [1:0] out; \n  wire w, w2; \n  assign w2 = in; \n  reg [1:0] state, nextstate; \n  parameter [1:0] s0 = 2'b00, s1 = 2'b01, s2 = 2'b10, s3 = 2'b11; \n  always @ (w2 or state ) \n  if(w2 == 2'b0) nextstate = state; \n  else \n  case (state) \n  s0: \n  begin \n  if(w2) begin nextstate = s1; out <= 2'b00; end \n  end \n  s1: \n  begin \n  if (w2) begin nextstate = s2; out<= 2'b01;end \n  end \n  s2: \n  begin \n  if (w2) begin nextstate = s3; out<= 2'b10;end \n  end \n  s3: \n  begin \n  if (w2) begin nextstate = s0; out <= 2'b11;end \n  end \n  default: begin \n  nextstate = 2'bx; \n  end \n  endcase \n  always @ (posedge clk or posedge rst) \n  begin \n  if (rst) begin state <= s0; end \n  else state <= nextstate; \n  end \n endmodule"}
{"task_id": "vector4", "detail_description": "One common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.Use the following description and code as an example:\nDescription: \n\nThis Verilog module, signext, takes a 16-bit input a and outputs a 32-bit result y. The output y is obtained by sign-extending the input a, i.e., it replicates the most significant bit of a 16 times and then appends the original 16 bits of a to the replicated bits.\n\n Module header:\n\nmodule signext(input [15:0] a,output [31:0] y);\n [/INST]\n\nAssociated Code:  \n  assign y = {{16{a[15]}}, a}; \n endmodule"}
{"task_id": "m2014_q4k", "detail_description": "Implement a shift register with four D flops. Reset is active-low synchronous resettable.Use the following description and code as an example:\nDescription: \n\nThis module implements a D flip-flop with synchronous reset functionality. The output Q is set to 1 when the reset signal R is low, and it follows the input D when the clock signal C transitions from high to low.\n\n Module header:\n\nmodule \\$_DFF_NN1_ (D, C, R, Q);\n [/INST]\n\nAssociated Code:  \n input D, C, R; \n output reg Q; \n always @(negedge C or negedge R) begin \n  if (R == 0) \n  Q <= 1; \n  else \n  Q <= D; \n end \n endmodule"}
{"task_id": "always_case2", "detail_description": "A priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.Use the following description and code as an example:\nDescription: \n\nThis module implements a priority encoder using the assign statement. It takes a 16-bit input and based on the enable signal, it outputs a 4-bit binary number representing the highest-order bit that is set in the input. If enable is low, the output is 0000. If enable is high, the output corresponds to the highest-order bit set in the input, with bit 15 being the highest priority and bit 0 being the lowest priority.\n\n Module header:\n\nmodule pri_encoder_using_assign (binary_out ,encoder_in ,enable);\n [/INST]\n\nAssociated Code:  \n output [3:0] binary_out ; \n input enable ; \n input [15:0] encoder_in ; \n wire [3:0] binary_out ; \n assign binary_out = (!enable) ? 0 : ((encoder_in == 16'bxxxx_xxxx_xxxx_xxx1) ? 0 :(encoder_in == 16'bxxxx_xxxx_xxxx_xx10) ? 1 :(encoder_in == 16'bxxxx_xxxx_xxxx_x100) ? 2 :(encoder_in == 16'bxxxx_xxxx_xxxx_1000) ? 3 :(encoder_in == 16'bxxxx_xxxx_xxx1_0000) ? 4 :(encoder_in == 16'bxxxx_xxxx_xx10_0000) ? 5 :(encoder_in == 16'bxxxx_xxxx_x100_0000) ? 6 :(encoder_in == 16'bxxxx_xxxx_1000_0000) ? 7 :(encoder_in == 16'bxxxx_xxx1_0000_0000) ? 8 :(encoder_in == 16'bxxxx_xx10_0000_0000) ? 9 :(encoder_in == 16'bxxxx_x100_0000_0000) ? 10 :(encoder_in == 16'bxxxx_1000_0000_0000) ? 11 :(encoder_in == 16'bxxx1_0000_0000_0000) ? 12 :(encoder_in == 16'bxx10_0000_0000_0000) ? 13 :(encoder_in == 16'bx100_0000_0000_0000) ? 14 : 15); \n endmodule "}
{"task_id": "fsm2", "detail_description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFFUse the following description and code as an example:\nDescription: \n\nThis Verilog module is a Moore finite state machine (FSM) with two input bits and one output bit. The module transitions between seven states based on the input and current state, and the output yout changes accordingly. The states and state transitions are defined with case statements and the output yout is assigned in each state based on the current state. The module operates on clock and reset signals and uses sequential and combinational logic to implement the state machine.\n\n Module header:\n\nmodule Moore_FSM(input clk,input reset,input [1:0] x,output reg yout);\n [/INST]\n\nAssociated Code:  \n  reg [2:0] state, nextState; \n  parameter s0 = 0, a0 = 1, a1 = 2, b0 = 3, b1 = 4, t0 = 5, t1 = 6; \n  always @(posedge clk or posedge reset) begin \n  if (reset) begin \n  state <= s0; \n  end \n  else begin \n  state <= nextState; \n  end \n  end \n  always @(x or state) begin \n  case (state) \n  s0: begin \n  case (x) \n  0: nextState <= s0; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  a0: begin \n  case (x) \n  0: nextState <= a1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  a1: begin \n  case (x) \n  0: nextState <= a1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  b0: begin \n  case (x) \n  0: nextState <= b1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  b1: begin \n  case (x) \n  0: nextState <= b1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  t0: begin \n  case (x) \n  0: nextState <= t1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  t1: begin \n  case (x) \n  0: nextState <= t1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  endcase \n  end \n  always @(state) begin \n  case (state) \n  s0, a1: yout <= 0; \n  a0, b0, t0: yout <= yout; \n  b1: yout <= 1; \n  t1: yout <= ~yout; \n  endcase \n  end \n endmodule"}
{"task_id": "m2014_q4i", "detail_description": "Build a circuit with no inputs and one output. That output should always drive 0 (or logic low).Use the following description and code as an example:\nDescription: \n\nThis Verilog module named GP_VSS implements a simple logic gate with an output named OUT. The output is constantly driven to 0, irrespective of any input signals.\n\n Module header:\n\nmodule GP_VSS(output OUT);\n [/INST]\n\nAssociated Code:  \n  assign OUT = 0; \n endmodule"}
{"task_id": "step_one", "detail_description": "Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a Gated Set/Reset (GSR) latch, with the output wire GSR constantly set to 1.\n\n Module header:\n\nmodule GSR(output wire GSR);\n [/INST]\n\nAssociated Code:  \n  assign GSR = 1; \n endmodule"}
{"task_id": "vector100r", "detail_description": "Given a 100-bit input vector [99:0], reverse its bit ordering.Use the following description and code as an example:\nDescription: \n\nThis Verilog module, named c_reverse, implements a reversible data transformation that takes an input of width bits and produces an output where the order of the bits is reversed. The input data_in is a vector of width bits, and the output data_out is also a vector of width bits. Inside the generate block, the module loops through each bit of the input and assigns the corresponding bit of the output to the inverted value of the input bit. This effectively reverses the order of the bits in the input and stores the result in the output.\n\n Module header:\n\nmodule c_reverse (data_in, data_out);\n [/INST]\n\nAssociated Code:  \n  parameter width = 32; \n  input [0:width-1] data_in; \n  output [0:width-1] data_out; \n  wire [0:width-1] data_out; \n  generate \n  genvar i; \n  for(i = 0; i < width; i = i + 1) \n  begin:connect \n  assign data_out[i] = data_in[(width-1)-i]; \n  end \n  endgenerate \n endmodule"}
{"task_id": "m2014_q4d", "detail_description": "Implement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a flip-flop with synchronous reset functionality. The output q is updated on the positive edge of the clk input, and is reset to 0 when the rst_n input is low, otherwise, it takes the value of the d input.\n\n Module header:\n\nmodule Flop (input clk,input d,input rst_n,output q);\n [/INST]\n\nAssociated Code:  \n  always @ (posedge clk or negedge rst_n) begin \n  if (!rst_n) q <= 1'b0; \n  else q <= d; \n  end \n endmodule"}
{"task_id": "shift4", "detail_description": "Build a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \nUse the following description and code as an example:\nDescription: \n\nThis module implements an 8-bit shift register with a parallel load capability. The shift register is loaded with the parallel input when the load signal is asserted, and it shifts its contents one bit to the left when the shift signal is asserted. The least significant bit (LSB) of the shift register is output as lsbout.\n\n Module header:\n\nmodule sr_lsb_first(clk, rstn, load, shift, parallelin, lsbout);\n [/INST]\n\nAssociated Code:  \n  input clk; \n  input rstn; \n  input load; \n  input shift; \n  input [7:0] parallelin; \n  output lsbout; \n  reg [7:0] shiftreg; \n  assign lsbout = shiftreg[0]; \n  always @(posedge clk or negedge rstn) begin \n  if(rstn == 0) \n  shiftreg <= 0; \n  else begin \n  if(load == 1) \n  shiftreg <= parallelin; \n  else if (shift == 1) begin \n  shiftreg[6:0] <= shiftreg[7:1]; \n  shiftreg[7] <= 0; \n  end \n  end \n  end \n endmodule"}
{"task_id": "truthtable1", "detail_description": "Create a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a 5-input Look-Up Table (LUT) that takes 5 inputs (in_4, in_3, in_2, in_1, in_0) and produces a single output (out) based on the provided truth table. The module uses the input values to select a row from the truth table, and the corresponding output value is assigned to the output signal. The truth table is represented by a 32-bit parameter. This module essentially acts as a configurable logic block, allowing the user to define custom logic functions based on the truth table.\n\n Module header:\n\nmodule LUT_5(in_4,in_3,in_2,in_1,in_0,out);\n [/INST]\n\nAssociated Code:  \n  parameter Truth_table=32'b00000000000000000000000000000000; \n  input in_0,in_1,in_2,in_3,in_4; \n  output reg out; \n  integer selected_row = 0; \n  wire [4:0] a; \n  interconnect inter0(in_0 , a[0]); \n  interconnect inter1(in_1 , a[1]); \n  interconnect inter2(in_2 , a[2]); \n  interconnect inter3(in_3 , a[3]); \n  interconnect inter4(in_4 , a[4]); \n  always@(a[0], a[1], a[2], a[3], a[4]) \n  begin \n  selected_row = {a[4], a[3], a[2], a[1], a[0]}; \n  out = Truth_table[selected_row]; \n  end \n endmodule"}
{"task_id": "dff8ar", "detail_description": "Create 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a global priority D flip-flop with asynchronous reset functionality. The flip-flop updates its output Q on the positive edge of the CLK signal, and resets to 0 when the nRST signal is low. The initial value of Q is set to 1'bx, and it updates to the input D when the reset condition is not active.\n\n Module header:\n\nmodule GP_DFFR(input D, CLK, nRST, output reg Q);\n [/INST]\n\nAssociated Code:  \n  parameter [0:0] INIT = 1'bx; \n  initial Q = INIT; \n  always @(posedge CLK, negedge nRST) begin \n  if (!nRST) \n  Q <= 1'b0; \n  else \n  Q <= D; \n  end \n endmodule"}
{"task_id": "gates100", "detail_description": "Build a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\nUse the following description and code as an example:\nDescription: \n\nThis Verilog module XOR8 implements an 8-input XOR gate. The output Y is assigned the result of XORing all the input signals A, B, C, D, E, F, G, and H.\n\n Module header:\n\nmodule XOR8 (input A, B, C, D, E, F, G, H,output Y);\n [/INST]\n\nAssociated Code:  \n  assign Y = A ^ B ^ C ^ D ^ E ^ F ^ G ^ H; \n endmodule"}
{"task_id": "hadd", "detail_description": "Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a 2-bit adder with carry-in and carry-out functionality. The sum and carry-out are calculated based on the inputs oper1, oper2, and cin, using bitwise logical operations such as AND, OR, and XOR. The module generates and propagates carry bits to ensure accurate addition.\n\n Module header:\n\nmodule adder_2b(sum, cout,oper1, oper2, cin);\n [/INST]\n\nAssociated Code:  \n input [1:0] oper1; \n input [1:0] oper2; \n input cin; \n output [1:0] sum; \n output cout; \n wire [1:0] gen, prop; \n wire [2:0] carry ; \n assign carry[0] = cin; \n assign gen[0] = oper1[0] & oper2[0] ; \n assign prop[0] = oper1[0] | oper2[0] ; \n assign sum[0] = oper1[0] ^ oper2[0] ^ carry[0] ; \n assign carry[1] = ( carry[0] & prop[0] ) | gen[0] ; \n assign gen[1] = oper1[1] & oper2[1] ; \n assign prop[1] = oper1[1] | oper2[1] ; \n assign sum[1] = oper1[1] ^ oper2[1] ^ carry[1] ; \n assign carry[2] = ( carry[0] & prop[0] & prop[1] ) | \n  ( gen[0] & prop[1] ) | \n  gen[1] ; \n assign cout = carry[2] ; \n endmodule"}
{"task_id": "always_if2", "detail_description": "Fix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\nUse the following description and code as an example:\nDescription: \n\nThis Verilog module is a memory unit for a CPU. It has inputs for reset, clock, CPU stall, and various control signals for memory operations. The outputs include data and control signals for memory operations. It performs memory read and write operations based on the input signals, and updates the control signals and output data based on the clock and CPU stall condition. It also handles reset conditions and data forwarding.\n\n Module header:\n\nmodule cpu_mem(rst, clk, cpu_stall, ex_c_rfw, ex_c_wbsource, ex_c_drw,ex_alu_r, ex_rfb, ex_rf_waddr, ex_jalra, ex_rt,wb_wdata, p_c_rfw, p_c_wbsource, p_alu_r, dmem_data,p_rf_waddr, p_jalra, dmem_addr, dmem_drw, dmem_in,p_dout);\n [/INST]\n\nAssociated Code:  \n  input rst, clk, cpu_stall; \n  input ex_c_rfw; \n  input [1:0] ex_c_wbsource; \n  input [1:0] ex_c_drw; \n  input [31:0] ex_alu_r; \n  input [31:0] ex_rfb; \n  input [4:0] ex_rf_waddr; \n  input [31:0] ex_jalra; \n  input [4:0] ex_rt; \n  input [31:0] wb_wdata; \n  output reg p_c_rfw; \n  output reg [1:0] p_c_wbsource; \n  output reg [31:0] p_alu_r; \n  output [31:0] dmem_data; \n  output reg [4:0] p_rf_waddr; \n  output reg [31:0] p_jalra; \n  output [31:0] dmem_addr; \n  output [1:0] dmem_drw; \n  input [31:0] dmem_in; \n  output reg [31:0] p_dout; \n  assign dmem_addr = ex_alu_r; \n  assign dmem_drw = ex_c_drw; \n  wire forward = p_c_rfw & (ex_rt == p_rf_waddr) & (p_rf_waddr != 0); \n  assign dmem_data = forward ? wb_wdata : ex_rfb; \n  always @(posedge clk) begin \n  if (!cpu_stall) begin \n  if (rst) begin \n  p_c_rfw <= 0; \n  p_c_wbsource <= 0; \n  p_alu_r <= 0; \n  p_rf_waddr <= 0; \n  p_jalra <= 0; \n  p_dout <= 0; \n  end else begin \n  p_c_rfw <= ex_c_rfw; \n  p_c_wbsource <= ex_c_wbsource; \n  p_alu_r <= ex_alu_r; \n  p_rf_waddr <= ex_rf_waddr; \n  p_jalra <= ex_jalra; \n  p_dout <= dmem_in; \n  end \n  end \n  end \n endmodule"}
{"task_id": "fsm2s", "detail_description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFFUse the following description and code as an example:\nDescription: \n\nThis Verilog module is a Moore finite state machine (FSM) with two input bits and one output bit. The module transitions between seven states based on the input and current state, and the output yout changes accordingly. The states and state transitions are defined with case statements and the output yout is assigned in each state based on the current state. The module operates on clock and reset signals and uses sequential and combinational logic to implement the state machine.\n\n Module header:\n\nmodule Moore_FSM(input clk,input reset,input [1:0] x,output reg yout);\n [/INST]\n\nAssociated Code:  \n  reg [2:0] state, nextState; \n  parameter s0 = 0, a0 = 1, a1 = 2, b0 = 3, b1 = 4, t0 = 5, t1 = 6; \n  always @(posedge clk or posedge reset) begin \n  if (reset) begin \n  state <= s0; \n  end \n  else begin \n  state <= nextState; \n  end \n  end \n  always @(x or state) begin \n  case (state) \n  s0: begin \n  case (x) \n  0: nextState <= s0; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  a0: begin \n  case (x) \n  0: nextState <= a1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  a1: begin \n  case (x) \n  0: nextState <= a1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  b0: begin \n  case (x) \n  0: nextState <= b1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  b1: begin \n  case (x) \n  0: nextState <= b1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  t0: begin \n  case (x) \n  0: nextState <= t1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  t1: begin \n  case (x) \n  0: nextState <= t1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  endcase \n  end \n  always @(state) begin \n  case (state) \n  s0, a1: yout <= 0; \n  a0, b0, t0: yout <= yout; \n  b1: yout <= 1; \n  t1: yout <= ~yout; \n  endcase \n  end \n endmodule"}
{"task_id": "vector3", "detail_description": "Given several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).Use the following description and code as an example:\nDescription: \n\nThis module, named sll_8, takes a 32-bit input 'a' and a single-bit 'lsb' as inputs, and generates an output 'out' of the same width. It uses generate blocks to perform 8-bit left shifts on the 'a' input and 8-bit left shifts on the 'lsb' input, and then assigns the results to the output 'out' in a concatenative manner.\n\n Module header:\n\nmodule sll_8(a, lsb, out);\n [/INST]\n\nAssociated Code:  \n  input [31:0] a; \n  input lsb; \n  output[31:0] out; \n  wire [31:0] out; \n  genvar i; \n  generate \n  for(i=8; i<32; i=i+1) begin: shift_eight_loop \n  assign out[i] = a[i-8]; \n  end \n  endgenerate \n  genvar j; \n  generate \n  for(j=0; j<8; j=j+1) begin: shift_eight_sub_loop \n  assign out[j] = lsb; \n  end \n  endgenerate \n endmodule "}
{"task_id": "circuit2", "detail_description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       Use the following description and code as an example:\nDescription: \n\nThis module is a behavioral description of a combinational logic circuit with inputs cx0 and cx1 and outputs bm0 through bm7. The outputs are assigned based on logic operations like AND, NOR, and inverters on the inputs and intermediate signals n1 and n2. The module uses basic logic gates like AND2X1, NOR2X1, OAI21X1, NAND2X1, and inverters to determine the outputs based on the input conditions.\n\n Module header:\n\nmodule bmu ( cx0, cx1, bm0, bm1, bm2, bm3, bm4, bm5, bm6, bm7 );\n [/INST]\n\nAssociated Code:  \n  output [1:0] bm0; \n  output [1:0] bm1; \n  output [1:0] bm2; \n  output [1:0] bm3; \n  output [1:0] bm4; \n  output [1:0] bm5; \n  output [1:0] bm6; \n  output [1:0] bm7; \n  input cx0, cx1; \n  wire bm2_1_, bm6_1_, n1, n2; \n  assign bm1[1] = bm2_1_; \n  assign bm2[1] = bm2_1_; \n  assign bm0[1] = bm3[1]; \n  assign bm0[0] = bm3[0]; \n  assign bm1[0] = bm3[0]; \n  assign bm2[0] = bm3[0]; \n  assign bm5[1] = bm6_1_; \n  assign bm6[1] = bm6_1_; \n  assign bm4[1] = bm7[1]; \n  assign bm4[0] = bm7[0]; \n  assign bm5[0] = bm7[0]; \n  assign bm6[0] = bm7[0]; \n  AND2X1 U31 ( .A(n1), .B(cx1), .Y(bm7[1]) ); \n  NOR2X1 U32 ( .A(cx1), .B(n1), .Y(bm6_1_) ); \n  INVX1 U33 ( .A(cx0), .Y(n1) ); \n  NOR2X1 U34 ( .A(bm3[1]), .B(bm3[0]), .Y(bm2_1_) ); \n  INVX1 U35 ( .A(bm7[0]), .Y(bm3[0]) ); \n  OAI21X1 U36 ( .A(cx1), .B(cx0), .C(n2), .Y(bm7[0]) ); \n  INVX1 U37 ( .A(n2), .Y(bm3[1]) ); \n  NAND2X1 U38 ( .A(cx0), .B(cx1), .Y(n2) ); \n endmodule"}
{"task_id": "andgate", "detail_description": "Create a module that implements an AND gate.Use the following description and code as an example:\nDescription: \n\nThis Verilog module is designed to implement the functionality of an AND gate. It takes two input signals, a and b, and produces an output signal, out, which is the logical AND of a and b. This is achieved through the use of an assign statement which computes the AND operation between the input signals a and b and assigns the result to the output signal out.\n\n Module header:\n\nmodule andgate(a, b, out);\n [/INST]\n\nAssociated Code:  \n  input a, b; \n  output out; \n  assign out = a & b; \n endmodule"}
{"task_id": "fsm1s", "detail_description": "This is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> AUse the following description and code as an example:\nDescription: \n\nThis Verilog module is a Moore finite state machine (FSM) with two input bits and one output bit. The module transitions between seven states based on the input and current state, and the output yout changes accordingly. The states and state transitions are defined with case statements and the output yout is assigned in each state based on the current state. The module operates on clock and reset signals and uses sequential and combinational logic to implement the state machine.\n\n Module header:\n\nmodule Moore_FSM(input clk,input reset,input [1:0] x,output reg yout);\n [/INST]\n\nAssociated Code:  \n  reg [2:0] state, nextState; \n  parameter s0 = 0, a0 = 1, a1 = 2, b0 = 3, b1 = 4, t0 = 5, t1 = 6; \n  always @(posedge clk or posedge reset) begin \n  if (reset) begin \n  state <= s0; \n  end \n  else begin \n  state <= nextState; \n  end \n  end \n  always @(x or state) begin \n  case (state) \n  s0: begin \n  case (x) \n  0: nextState <= s0; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  a0: begin \n  case (x) \n  0: nextState <= a1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  a1: begin \n  case (x) \n  0: nextState <= a1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  b0: begin \n  case (x) \n  0: nextState <= b1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  b1: begin \n  case (x) \n  0: nextState <= b1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  t0: begin \n  case (x) \n  0: nextState <= t1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  t1: begin \n  case (x) \n  0: nextState <= t1; \n  1: nextState <= a0; \n  2: nextState <= t0; \n  3: nextState <= b0; \n  endcase \n  end \n  endcase \n  end \n  always @(state) begin \n  case (state) \n  s0, a1: yout <= 0; \n  a0, b0, t0: yout <= yout; \n  b1: yout <= 1; \n  t1: yout <= ~yout; \n  endcase \n  end \n endmodule"}
{"task_id": "fadd", "detail_description": "Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a 2-bit adder with carry-in and carry-out functionality. The sum and carry-out are calculated based on the inputs oper1, oper2, and cin, using bitwise logical operations such as AND, OR, and XOR. The module generates and propagates carry bits to ensure accurate addition.\n\n Module header:\n\nmodule adder_2b(sum, cout,oper1, oper2, cin);\n [/INST]\n\nAssociated Code:  \n input [1:0] oper1; \n input [1:0] oper2; \n input cin; \n output [1:0] sum; \n output cout; \n wire [1:0] gen, prop; \n wire [2:0] carry ; \n assign carry[0] = cin; \n assign gen[0] = oper1[0] & oper2[0] ; \n assign prop[0] = oper1[0] | oper2[0] ; \n assign sum[0] = oper1[0] ^ oper2[0] ^ carry[0] ; \n assign carry[1] = ( carry[0] & prop[0] ) | gen[0] ; \n assign gen[1] = oper1[1] & oper2[1] ; \n assign prop[1] = oper1[1] | oper2[1] ; \n assign sum[1] = oper1[1] ^ oper2[1] ^ carry[1] ; \n assign carry[2] = ( carry[0] & prop[0] & prop[1] ) | \n  ( gen[0] & prop[1] ) | \n  gen[1] ; \n assign cout = carry[2] ; \n endmodule"}
{"task_id": "m2014_q4g", "detail_description": "Implement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a simple XOR logic operation. The output 'out' is the result of the XOR operation between inputs 'a' and 'b'.\n\n Module header:\n\nmodule Mxor (output out, input a, b);\n [/INST]\n\nAssociated Code:  \n  assign out = (a ^ b); \n endmodule"}
{"task_id": "ece241_2014_q3", "detail_description": "For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\nUse the following description and code as an example:\nDescription: \n\nThis Verilog module implements a 4-to-1 multiplexer. It selects one of the input signals A, B, C, or D based on the 2-bit enable input and assigns the selected signal to the output O. The module uses a case statement to handle the different enable input combinations and assigns the corresponding input signal to the output.\n\n Module header:\n\nmodule mux_4_to_1_5(input [4:0] A,B,C,D,input [1:0] enable,output reg[4:0] O);\n [/INST]\n\nAssociated Code:  \n  always @* begin \n  case (enable) \n  2'b00 : begin \n  O <= A; \n  end \n  2'b01 : begin \n  O <= B; \n  end \n  2'b10 : begin \n  O <= C; \n  end \n  2'b11 : begin \n  O <= D; \n  end \n  endcase \n  end \n endmodule"}
{"task_id": "ece241_2014_q5b", "detail_description": "The following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> BUse the following description and code as an example:\nDescription: \n\nThis Verilog module, \"True2Comp\", converts a two's complement binary number into its one's complement representation. It takes in a binary input \"true\" and produces the one's complement representation in the \"complement\" output. The module is parameterized by the number of data channels and the width of each data channel. It uses a generate block to loop through the data channels and perform the conversion for each channel. The conversion is done by checking the most significant bit of each channel and either preserving the value as is or performing a bitwise complement operation.\n\n Module header:\n\nmodule True2Comp(true,complement);\n [/INST]\n\nAssociated Code:  \n  parameter data_channel = 1; \n  parameter data_width = 17; \n  input[data_channel * data_width - 1 : 0] true; \n  output[data_channel * data_width - 1 : 0] complement; \n  genvar i; \n  generate \n  `define h (i + 1) * data_width - 1 \n  `define l i * data_width \n  for (i = 0; i < data_channel; i = i + 1) begin \n  assign complement[`h : `l] = true[`h] == 0 ? \n  true[`h : `l] : {1'b1, ~true[`h - 1 : `l] + 1}; \n  end \n  `undef h \n  `undef l \n  endgenerate \n endmodule"}
{"task_id": "circuit10", "detail_description": "This is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a D flip-flop with Set-Reset (DFFSRX1). The inputs include D (data input), CLK (clock input), SETB (set input), and RSTB (reset input). The module also provides Q and QN (inverted Q) as outputs. Inside the module, temporary wires Qtemp and Dtemp are used to calculate the Q and QN outputs. The Dtemp is computed based on D and SETB. The Dtemp is then connected to an instantiated FDR module, which is the core element of the DFFSRX1, and the connections are established to determine the Qtemp output. Finally, Qtemp is assigned to Q, and the inverted Qtemp is assigned to QN.\n\n Module header:\n\nmodule DFFSSRX1 (D,CLK,SETB,RSTB,Q,QN);\n [/INST]\n\nAssociated Code:  \n  input D; \n  input CLK; \n  input RSTB; \n  input SETB; \n  output Q; \n  output QN; \n  wire Qtemp; \n  wire Dtemp; \n  assign QN = ~Qtemp; \n  assign Q = Qtemp; \n  assign Dtemp = D || !SETB; \n  FDR XIL_FDR (.D(Dtemp),.C(CLK),.R(~(RSTB)),.Q(Qtemp)); \n endmodule"}
{"task_id": "2012_q1g", "detail_description": "Consider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |Use the following description and code as an example:\nDescription: \n\nThe \"lcol\" module takes inputs \"x\" and \"in_cell\" and produces the output \"out_cell\" based on the value of \"LOOKUP\". The \"LOOKUP\" function takes input \"lookup_type\", \"input_cell\", and \"obstacle\", and produces a 7-bit output. Depending on the values of \"input_cell\" and \"obstacle\", \"LOOKUP\" is determined either by bitwise manipulation or by a specific case based on \"lookup_type\". The \"out_cell\" is assigned based on the \"input_cell\" and the result of \"LOOKUP\".\n\n Module header:\n\nmodule lcol (input x,input [7:0] in_cell,output [7:0] out_cell);\n [/INST]\n\nAssociated Code:  \n  function [6:0] LOOKUP; \n  input lookup_type; \n  input [6:0] input_cell; \n  input obstacle; \n  begin \n  if ( obstacle ) \n  LOOKUP = { input_cell[6], input_cell[2:0], input_cell[5:3] }; \n  else if ( lookup_type == 1 ) begin \n  case ( input_cell ) \n  7'd18: \n  LOOKUP = 7'd36; \n  7'd9: \n  LOOKUP = 7'd18; \n  7'd36: \n  LOOKUP = 7'd9; \n  7'd96: \n  LOOKUP = 7'd17; \n  7'd80: \n  LOOKUP = 7'd40; \n  7'd72: \n  LOOKUP = 7'd20; \n  7'd68: \n  LOOKUP = 7'd10; \n  7'd66: \n  LOOKUP = 7'd5; \n  7'd65: \n  LOOKUP = 7'd34; \n  7'd20: \n  LOOKUP = 7'd72; \n  7'd40: \n  LOOKUP = 7'd80; \n  7'd17: \n  LOOKUP = 7'd96; \n  7'd34: \n  LOOKUP = 7'd65; \n  7'd5: \n  LOOKUP = 7'd66; \n  7'd10: \n  LOOKUP = 7'd68; \n  7'd21: \n  LOOKUP = 7'd42; \n  7'd42: \n  LOOKUP = 7'd21; \n  7'd100: \n  LOOKUP = 7'd73; \n  7'd82: \n  LOOKUP = 7'd100; \n  7'd73: \n  LOOKUP = 7'd82; \n  7'd85: \n  LOOKUP = 7'd106; \n  7'd106: \n  LOOKUP = 7'd85; \n  default: \n  LOOKUP = 7'd0; \n  endcase \n  end \n  else begin \n  case ( input_cell ) \n  7'd18: \n  LOOKUP = 7'd9; \n  7'd9: \n  LOOKUP = 7'd36; \n  7'd36: \n  LOOKUP = 7'd18; \n  7'd96: \n  LOOKUP = 7'd17; \n  7'd80: \n  LOOKUP = 7'd40; \n  7'd72: \n  LOOKUP = 7'd20; \n  7'd68: \n  LOOKUP = 7'd10; \n  7'd66: \n  LOOKUP = 7'd5; \n  7'd65: \n  LOOKUP = 7'd34; \n  7'd20: \n  LOOKUP = 7'd72; \n  7'd40: \n  LOOKUP = 7'd80; \n  7'd17: \n  LOOKUP = 7'd96; \n  7'd34: \n  LOOKUP = 7'd65; \n  7'd5: \n  LOOKUP = 7'd66; \n  7'd10: \n  LOOKUP = 7'd68; \n  7'd21: \n  LOOKUP = 7'd42; \n  7'd42: \n  LOOKUP = 7'd21; \n  7'd100: \n  LOOKUP = 7'd82; \n  7'd82: \n  LOOKUP = 7'd73; \n  7'd73: \n  LOOKUP = 7'd100; \n  7'd85: \n  LOOKUP = 7'd106; \n  7'd106: \n  LOOKUP = 7'd85; \n  default: \n  LOOKUP = 7'd0; \n  endcase \n  end \n  end \n  endfunction \n  assign out_cell = { in_cell[7], LOOKUP( x, in_cell[6:0], in_cell[7]) }; \n endmodule"}
{"task_id": "fsm_hdlc", "detail_description": "Synchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.Use the following description and code as an example:\nDescription: \n\nThis Verilog module `aur1_FRAME_CHECK` implements a frame checking logic. It takes in a 64-bit data `RX_D`, a data valid signal `RX_SRC_RDY_N`, a user clock signal `USER_CLK`, a reset signal `RESET`, and a channel up signal `CHANNEL_UP`. It outputs an 8-bit error count `ERR_COUNT`.\n\nThe module uses a linear feedback shift register (LFSR) to perform the frame checking. When the reset condition is met, the LFSR is initialized with a specific value. On each clock cycle, if the data is valid, the LFSR is updated. The incoming data `RX_D` is compared with the LFSR output `data_lfsr_concat_w` to detect errors.\n\nThe module also checks for the reset condition and updates the error count based on the detected errors. The error count is incremented if a data error is detected.\n\nOverall, this module is designed to check for frame errors in the incoming data and maintain an error count.\n\n Module header:\n\nmodule aur1_FRAME_CHECK (RX_D,RX_SRC_RDY_N,USER_CLK,RESET,CHANNEL_UP,ERR_COUNT);\n [/INST]\n\nAssociated Code:  \n  input [0:63] RX_D; \n  input RX_SRC_RDY_N; \n  input USER_CLK; \n  input RESET; \n  input CHANNEL_UP; \n  output [0:7] ERR_COUNT; \n  reg [0:7] ERR_COUNT; \n  reg [0:15] data_lfsr_r; \n  wire reset_c; \n  wire [0:63] data_lfsr_concat_w; \n  wire data_valid_c; \n  wire data_error_detected_c; \n  assign reset_c = RESET || !CHANNEL_UP; \n  assign data_valid_c = !RX_SRC_RDY_N; \n  always @(posedge USER_CLK) \n  if(reset_c) \n  begin \n  data_lfsr_r <= `DLY 16'hD5E6; \n  end \n  else if(data_valid_c) \n  begin \n  data_lfsr_r <= `DLY {!{data_lfsr_r[3]^data_lfsr_r[12]^data_lfsr_r[14]^data_lfsr_r[15]}, \n  data_lfsr_r[0:14]}; \n  end \n  assign data_lfsr_concat_w = {4{data_lfsr_r}}; \n  assign data_error_detected_c = (data_valid_c && (RX_D != data_lfsr_concat_w)); \n  always @(posedge USER_CLK) \n  if(reset_c) \n  ERR_COUNT <= `DLY 8'd0; \n  else if(&ERR_COUNT) \n  ERR_COUNT <= `DLY ERR_COUNT; \n  else if(data_error_detected_c) \n  ERR_COUNT <= `DLY ERR_COUNT + 1; \n endmodule "}
{"task_id": "review2015_fancytimer", "detail_description": "We want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \nUse the following description and code as an example:\nDescription: \n\nThis Verilog module is a millisecond timer that uses a state machine to control the delay. It has an input clock, reset signal, and delay start signal, along with a parameter for the system clock frequency and a parameter for the delay width. The delay time is specified using the input delay_ms, and the output delay_fin indicates when the delay is finished.\n\nThe module contains a state machine with three states: IDLE, WAIT, and DONE. The timer_state variable represents the current state, and it transitions between these states based on the input signals and internal counters.\n\nWhen the delay_start signal is asserted, the module enters the WAIT state and counts the number of system clock cycles until the specified delay_ms is reached. Once the delay is reached, the module transitions to the DONE state and sets the delay_fin signal.\n\nThe module also includes a microsecond counter, a system clock counter, and a delayed microsecond counter, which are used to manage the timing of the delay.\n\nAdditionally, the module includes a function to calculate the log base 2 of a value, which is used to determine the width of the system clock counter based on the specified system clock frequency.\n\nOverall, the module acts as a configurable millisecond timer with a state machine to control the delay timing.\n\n Module header:\n\nmodule milisecond_timer #(parameter SYS_CLK_KHZ = 50,parameter DELAY_W = 12) (input clk,input reset,input delay_start,input [DELAY_W-1:0] delay_ms,output delay_fin);\n [/INST]\n\nAssociated Code:  \n `define MS_TIMER_SM_W 2 \n localparam STATE_IDLE = `MS_TIMER_SM_W'h0; \n localparam STATE_WAIT = `MS_TIMER_SM_W'h1; \n localparam STATE_DONE = `MS_TIMER_SM_W'h2; \n localparam SYS_CLK_W = log2(SYS_CLK_KHZ); \n reg [`MS_TIMER_SM_W-1:0] timer_state; \n reg [DELAY_W-1:0] ms_counter; \n reg [DELAY_W-1:0] delay_ms_latched; \n reg [SYS_CLK_W-1:0] sys_clk_counter; \n assign delay_fin = ( (timer_state==STATE_DONE) && (delay_start==1'b0) ) ? 1'b1 : 1'b0; \n always @(posedge clk or posedge reset) begin \n  if (reset) begin \n  timer_state <= STATE_IDLE; \n  delay_ms_latched <= 'b0; \n  end else begin \n  case (timer_state) \n  STATE_IDLE: begin \n  if (delay_start==1'b1) begin \n  timer_state <= STATE_WAIT; \n  delay_ms_latched <= delay_ms; \n  end \n  end \n  STATE_WAIT: begin \n  if (ms_counter == delay_ms_latched) begin \n  timer_state <= STATE_DONE; \n  delay_ms_latched <= 'b0; \n  end \n  end \n  STATE_DONE: begin \n  if (delay_start==1'b0) begin \n  timer_state <= STATE_IDLE; \n  end \n  end \n  endcase \n  end \n end \n always @(posedge clk or posedge reset) begin \n  if (reset) begin \n  sys_clk_counter <= 'b0; \n  ms_counter <= 'b0; \n  end else begin \n  if (timer_state==STATE_WAIT) begin \n  if (sys_clk_counter == SYS_CLK_KHZ ) begin \n  sys_clk_counter <= 'b0; \n  ms_counter <= ms_counter + 1; \n  end else begin \n  sys_clk_counter <= sys_clk_counter + 1; \n  end \n  end else begin \n  sys_clk_counter <= 'b0; \n  ms_counter <= 'b0; \n  end \n  end \n end \n function [5:0] log2; \n  input [31:0] val; \n  integer i; \n  begin \n  for (i=32; i>0; i=i-1) begin \n  if (val>(32'b1<<(i-1))) begin \n  log2 = i; \n  i = 0; \n  end else begin \n  log2 = 1; \n  end \n  end \n  end \n endfunction \n endmodule"}
{"task_id": "ece241_2013_q4", "detail_description": "A large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a water level control system with a water inlet and outlet. It tracks the water level and controls the water inlet and outlet accordingly. The module includes a water count, water sign mode, and an initialization flag. It uses a timer for water inlet control. The water level is calculated based on the input signals, and the module controls the water inlet and outlet accordingly. The water inlet and outlet end signals are set based on the water sign mode. The module resets the water level and end signals when necessary.\n\n Module header:\n\nmodule water_let_mode #(parameter WIDTH = 32, CLK_CH = 25, TIME_SCORE = 2) (input power,input start,input [31:0]clk,input water_in_start,input water_out_start,input [2:0]max_water_level,output reg water_in_end_sign,output reg water_out_end_sign,output reg [2:0]water_level);\n [/INST]\n\nAssociated Code:  \n  reg init_flag; \n  wire [(WIDTH-1):0]water_count; \n  wire water_sign_mode; \n  initial begin \n  init_flag <= 1; \n  water_in_end_sign = 1'b0; \n  water_out_end_sign = 1'b0; \n  water_level = {3{1'b0}}; \n  end \n timer #(WIDTH, CLK_CH, TIME_SCORE) WATER_IN_TIMER (.clk_src(clk),.switch_power(power),.switch_en(start),.sum_count({{29{1'b0}}, max_water_level}),.count_start_flag(water_in_start | water_out_start),.count_end_flag(water_sign_mode),.count(water_count)); \n  always @(posedge clk[0]) begin \n  if (power & (water_in_start | water_out_start)) begin \n  if(init_flag) begin \n  if (water_in_start) begin \n  water_level = {3{1'b0}}; \n  end else if (water_out_start) begin \n  water_level = max_water_level; \n  init_flag = 0; \n  end \n  end \n  if (start) begin \n  if (water_in_start) begin \n  water_level = max_water_level - water_count[0] - water_count[1] * 2 - water_count[2] * 4; \n  water_in_end_sign = water_sign_mode; \n  end else if (water_out_start) begin \n  water_level = water_count[0] + water_count[1] * 2 + water_count[2] * 4; \n  water_out_end_sign = water_sign_mode; \n  end \n  end \n  end else begin \n  init_flag <= 1; \n  water_in_end_sign = 1'b0; \n  water_out_end_sign = 1'b0; \n  water_level = {3{1'b0}}; \n  end \n  end \n endmodule"}
{"task_id": "fsm_serial", "detail_description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.Use the following description and code as an example:\nDescription: \n\nThe Verilog module is a finite state machine (FSM) for 32-bit byte enable. It takes clock, reset, write, byte-enable, and wait request signals as inputs, and provides wait request and byte enable signals as outputs. \n\nThe module includes a 2-bit state register and logic to control the state transition. It also uses partial and full transfer flags for the lower and upper halves, as well as two-stage transfer, to determine the state transitions.\n\nThe state transition logic operates based on various conditions such as transfer completion, advancing to the next state, enabling lower and upper halves, and stalling. It also interfaces with two 16-bit byte enable FSMs for the lower and upper halves of the 32-bit data.\n\nThe wait request output is determined based on the input and transfer status. The module effectively controls the transfer of data based on the byte enable and write signals while managing the wait request status.\n\nOverall, the module coordinates the transfer of data based on byte enable signals, ensuring proper handling of partial and full transfers, and managing wait request status effectively.\n\n Module header:\n\nmodule thirty_two_bit_byteenable_FSM (clk,reset,write_in,byteenable_in,waitrequest_out,byteenable_out,waitrequest_in);\n [/INST]\n\nAssociated Code:  \n  input clk; \n  input reset; \n  input write_in; \n  input [3:0] byteenable_in; \n  output wire waitrequest_out; \n  output wire [3:0] byteenable_out; \n  input waitrequest_in; \n  wire partial_lower_half_transfer; \n  wire full_lower_half_transfer; \n  wire partial_upper_half_transfer; \n  wire full_upper_half_transfer; \n  wire full_word_transfer; \n  reg state_bit; \n  wire transfer_done; \n  wire advance_to_next_state; \n  wire lower_enable; \n  wire upper_enable; \n  wire lower_stall; \n  wire upper_stall; \n  wire two_stage_transfer; \n  always @ (posedge clk or posedge reset) \n  begin \n  if (reset) \n  begin \n  state_bit <= 0; \n  end \n  else \n  begin \n  if (transfer_done == 1) \n  begin \n  state_bit <= 0; \n  end \n  else if (advance_to_next_state == 1) \n  begin \n  state_bit <= 1; \n  end \n  end \n  end \n  assign partial_lower_half_transfer = (byteenable_in[1:0] != 0); \n  assign full_lower_half_transfer = (byteenable_in[1:0] == 2'h3); \n  assign partial_upper_half_transfer = (byteenable_in[3:2] != 0); \n  assign full_upper_half_transfer = (byteenable_in[3:2] == 2'h3); \n  assign full_word_transfer = (full_lower_half_transfer == 1) & (full_upper_half_transfer == 1); \n  assign two_stage_transfer = (full_word_transfer == 0) & (partial_lower_half_transfer == 1) & (partial_upper_half_transfer == 1); \n  assign advance_to_next_state = (two_stage_transfer == 1) & (lower_stall == 0) & (write_in == 1) & (state_bit == 0) & (waitrequest_in == 0); \n  assign transfer_done = ((full_word_transfer == 1) & (waitrequest_in == 0) & (write_in == 1)) | \n  ((two_stage_transfer == 0) & (lower_stall == 0) & (upper_stall == 0) & (write_in == 1) & (waitrequest_in == 0)) | \n  ((two_stage_transfer == 1) & (state_bit == 1) & (upper_stall == 0) & (write_in == 1) & (waitrequest_in == 0)); \n  assign lower_enable = ((write_in == 1) & (full_word_transfer == 1)) | \n  ((write_in == 1) & (two_stage_transfer == 0) & (partial_lower_half_transfer == 1)) | \n  ((write_in == 1) & (two_stage_transfer == 1) & (partial_lower_half_transfer == 1) & (state_bit == 0)); \n  assign upper_enable = ((write_in == 1) & (full_word_transfer == 1)) | \n  ((write_in == 1) & (two_stage_transfer == 0) & (partial_upper_half_transfer == 1)) | \n  ((write_in == 1) & (two_stage_transfer == 1) & (partial_upper_half_transfer == 1) & (state_bit == 1)); \n sixteen_bit_byteenable_FSM lower_sixteen_bit_byteenable_FSM (.write_in (lower_enable),.byteenable_in (byteenable_in[1:0]),.waitrequest_out (lower_stall),.byteenable_out (byteenable_out[1:0]),.waitrequest_in (waitrequest_in)); \n sixteen_bit_byteenable_FSM upper_sixteen_bit_byteenable_FSM (.write_in (upper_enable),.byteenable_in (byteenable_in[3:2]),.waitrequest_out (upper_stall),.byteenable_out (byteenable_out[3:2]),.waitrequest_in (waitrequest_in)); \n  assign waitrequest_out = (waitrequest_in == 1) | ((transfer_done == 0) & (write_in == 1)); \n endmodule"}
{"task_id": "fsm_serialdata", "detail_description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.Use the following description and code as an example:\nDescription: \n\nThe Verilog module is a finite state machine (FSM) for 32-bit byte enable. It takes clock, reset, write, byte-enable, and wait request signals as inputs, and provides wait request and byte enable signals as outputs. \n\nThe module includes a 2-bit state register and logic to control the state transition. It also uses partial and full transfer flags for the lower and upper halves, as well as two-stage transfer, to determine the state transitions.\n\nThe state transition logic operates based on various conditions such as transfer completion, advancing to the next state, enabling lower and upper halves, and stalling. It also interfaces with two 16-bit byte enable FSMs for the lower and upper halves of the 32-bit data.\n\nThe wait request output is determined based on the input and transfer status. The module effectively controls the transfer of data based on the byte enable and write signals while managing the wait request status.\n\nOverall, the module coordinates the transfer of data based on byte enable signals, ensuring proper handling of partial and full transfers, and managing wait request status effectively.\n\n Module header:\n\nmodule thirty_two_bit_byteenable_FSM (clk,reset,write_in,byteenable_in,waitrequest_out,byteenable_out,waitrequest_in);\n [/INST]\n\nAssociated Code:  \n  input clk; \n  input reset; \n  input write_in; \n  input [3:0] byteenable_in; \n  output wire waitrequest_out; \n  output wire [3:0] byteenable_out; \n  input waitrequest_in; \n  wire partial_lower_half_transfer; \n  wire full_lower_half_transfer; \n  wire partial_upper_half_transfer; \n  wire full_upper_half_transfer; \n  wire full_word_transfer; \n  reg state_bit; \n  wire transfer_done; \n  wire advance_to_next_state; \n  wire lower_enable; \n  wire upper_enable; \n  wire lower_stall; \n  wire upper_stall; \n  wire two_stage_transfer; \n  always @ (posedge clk or posedge reset) \n  begin \n  if (reset) \n  begin \n  state_bit <= 0; \n  end \n  else \n  begin \n  if (transfer_done == 1) \n  begin \n  state_bit <= 0; \n  end \n  else if (advance_to_next_state == 1) \n  begin \n  state_bit <= 1; \n  end \n  end \n  end \n  assign partial_lower_half_transfer = (byteenable_in[1:0] != 0); \n  assign full_lower_half_transfer = (byteenable_in[1:0] == 2'h3); \n  assign partial_upper_half_transfer = (byteenable_in[3:2] != 0); \n  assign full_upper_half_transfer = (byteenable_in[3:2] == 2'h3); \n  assign full_word_transfer = (full_lower_half_transfer == 1) & (full_upper_half_transfer == 1); \n  assign two_stage_transfer = (full_word_transfer == 0) & (partial_lower_half_transfer == 1) & (partial_upper_half_transfer == 1); \n  assign advance_to_next_state = (two_stage_transfer == 1) & (lower_stall == 0) & (write_in == 1) & (state_bit == 0) & (waitrequest_in == 0); \n  assign transfer_done = ((full_word_transfer == 1) & (waitrequest_in == 0) & (write_in == 1)) | \n  ((two_stage_transfer == 0) & (lower_stall == 0) & (upper_stall == 0) & (write_in == 1) & (waitrequest_in == 0)) | \n  ((two_stage_transfer == 1) & (state_bit == 1) & (upper_stall == 0) & (write_in == 1) & (waitrequest_in == 0)); \n  assign lower_enable = ((write_in == 1) & (full_word_transfer == 1)) | \n  ((write_in == 1) & (two_stage_transfer == 0) & (partial_lower_half_transfer == 1)) | \n  ((write_in == 1) & (two_stage_transfer == 1) & (partial_lower_half_transfer == 1) & (state_bit == 0)); \n  assign upper_enable = ((write_in == 1) & (full_word_transfer == 1)) | \n  ((write_in == 1) & (two_stage_transfer == 0) & (partial_upper_half_transfer == 1)) | \n  ((write_in == 1) & (two_stage_transfer == 1) & (partial_upper_half_transfer == 1) & (state_bit == 1)); \n sixteen_bit_byteenable_FSM lower_sixteen_bit_byteenable_FSM (.write_in (lower_enable),.byteenable_in (byteenable_in[1:0]),.waitrequest_out (lower_stall),.byteenable_out (byteenable_out[1:0]),.waitrequest_in (waitrequest_in)); \n sixteen_bit_byteenable_FSM upper_sixteen_bit_byteenable_FSM (.write_in (upper_enable),.byteenable_in (byteenable_in[3:2]),.waitrequest_out (upper_stall),.byteenable_out (byteenable_out[3:2]),.waitrequest_in (waitrequest_in)); \n  assign waitrequest_out = (waitrequest_in == 1) | ((transfer_done == 0) & (write_in == 1)); \n endmodule"}
{"task_id": "gshare", "detail_description": "Build a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.Use the following description and code as an example:\nDescription: \n\nThis Verilog module is a branch predictor, implementing a gshare predictor with a FSM (finite state machine). It uses the history of branch outcomes to predict the next branch. The module has inputs for clock, reset, various control signals, and branch addresses. The predicted_flag_o output indicates the predicted outcome of the branch. The module updates its internal state based on the branch outcomes and uses this state to make predictions. It also updates the branch history based on the branch outcomes and the history. The FSM has four states: strongly not taken, weakly not taken, weakly taken, and strongly taken. The module also includes logic for handling reset, updating the history, and handling different branch outcomes to update the state accordingly.\n\n Module header:\n\nmodule mor1kx_branch_predictor_gshare #(parameter GSHARE_BITS_NUM = 10,parameter OPTION_OPERAND_WIDTH = 32) (input clk,input rst,output predicted_flag_o,input execute_op_bf_i,input execute_op_bnf_i,input op_bf_i,input op_bnf_i,input padv_decode_i,input flag_i,input prev_op_brcond_i,input branch_mispredict_i,input [OPTION_OPERAND_WIDTH-1:0] brn_pc_i);\n [/INST]\n\nAssociated Code:  \n  localparam [1:0] \n  STATE_STRONGLY_NOT_TAKEN = 2'b00, \n  STATE_WEAKLY_NOT_TAKEN = 2'b01, \n  STATE_WEAKLY_TAKEN = 2'b10, \n  STATE_STRONGLY_TAKEN = 2'b11; \n  localparam FSM_NUM = 2 ** GSHARE_BITS_NUM; \n  integer i = 0; \n  reg [1:0] state [0:FSM_NUM]; \n  reg [GSHARE_BITS_NUM:0] brn_hist_reg = 0; \n  reg [GSHARE_BITS_NUM - 1:0] prev_idx = 0; \n  wire [GSHARE_BITS_NUM - 1:0] state_index = brn_hist_reg[GSHARE_BITS_NUM - 1:0] ^ brn_pc_i[GSHARE_BITS_NUM + 1:2]; \n  assign predicted_flag_o = (state[state_index][1] && op_bf_i) || \n  (!state[state_index][1] && op_bnf_i); \n  wire brn_taken = (execute_op_bf_i && flag_i) || (execute_op_bnf_i && !flag_i); \n  always @(posedge clk) begin \n  if (rst) begin \n  brn_hist_reg <= 0; \n  prev_idx <= 0; \n  for(i = 0; i < FSM_NUM; i = i + 1) begin \n  state[i] = STATE_WEAKLY_TAKEN; \n  end \n  end else begin \n  if (op_bf_i || op_bnf_i) begin \n  prev_idx <= state_index; \n  end \n  if (prev_op_brcond_i && padv_decode_i) begin \n  brn_hist_reg <= {brn_hist_reg[GSHARE_BITS_NUM - 1 : 0], brn_taken}; \n  if (!brn_taken) begin \n  case (state[prev_idx]) \n  STATE_STRONGLY_TAKEN: \n  state[prev_idx] <= STATE_WEAKLY_TAKEN; \n  STATE_WEAKLY_TAKEN: \n  state[prev_idx] <= STATE_WEAKLY_NOT_TAKEN; \n  STATE_WEAKLY_NOT_TAKEN: \n  state[prev_idx] <= STATE_STRONGLY_NOT_TAKEN; \n  STATE_STRONGLY_NOT_TAKEN: \n  state[prev_idx] <= STATE_STRONGLY_NOT_TAKEN; \n  endcase \n  end else begin \n  case (state[prev_idx]) \n  STATE_STRONGLY_NOT_TAKEN: \n  state[prev_idx] <= STATE_WEAKLY_NOT_TAKEN; \n  STATE_WEAKLY_NOT_TAKEN: \n  state[prev_idx] <= STATE_WEAKLY_TAKEN; \n  STATE_WEAKLY_TAKEN: \n  state[prev_idx] <= STATE_STRONGLY_TAKEN; \n  STATE_STRONGLY_TAKEN: \n  state[prev_idx] <= STATE_STRONGLY_TAKEN; \n  endcase \n  end \n  end \n  end \n  end \n endmodule"}
{"task_id": "lemmings4", "detail_description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a finite state machine for a two-player game. It has various states such as P1_Move, P1_Status, P2_Move, P2_Status, Win, Tie, and Loss, and transitions between these states based on player moves and game outcomes. The module tracks player turns and game status using input and output signals.\n\n Module header:\n\nmodule Gato_FSM(clk,reset,state,p1_mm,p2_mm,p1_tie,p1_loss,p1_win,p2_tie,p2_loss,p2_win,verifica_status,turno_p1,turno_p2,win_game,loss_game,tie_game);\n [/INST]\n\nAssociated Code:  \n  input clk, reset; \n  input p1_mm, p2_mm; \n  input p1_tie, p1_loss, p1_win, p2_tie, p2_loss, p2_win; \n  output reg turno_p1, turno_p2; \n  output reg verifica_status; \n  output reg win_game, loss_game, tie_game; \n  output [3:0] state; \n  reg [3:0] state, nextState; \n  parameter P1_Move = 0; \n  parameter P1_Status = 1; \n  parameter P2_Move = 2; \n  parameter P2_Status = 3; \n  parameter Win = 4; \n  parameter Tie = 5; \n  parameter Loss = 6; \n  initial turno_p1 <= 1'b1; \n  initial turno_p2 <= 1'b0; \n  always @(posedge clk or posedge reset) \n  begin \n  if (reset) \n  state <= P1_Move; \n  else \n  state <= nextState; \n  end \n  always @(state or p1_mm or p2_mm or p1_win or p1_loss or p1_tie or p2_win or p2_loss or p2_tie) \n  begin \n  nextState = 3'bxxx; \n  case(state) \n  P1_Move: \n  begin \n  verifica_status <= 1'b0; \n  turno_p1 <= 1'b1; \n  turno_p2 <= 1'b0; \n  if (p1_mm == 1'b0) \n  nextState = P1_Move; \n  else if (p1_mm == 1'b1) \n  nextState = P1_Status; \n  end \n  P1_Status: \n  begin \n  verifica_status <= 1'b1; \n  turno_p1 <= 1'b0; \n  turno_p2 <= 1'b1; \n  if (p1_tie == 1'b1 & p1_loss == 1'b0 & p1_win == 1'b0) \n  nextState = Tie; \n  else if (p1_win == 1'b1 & p1_tie == 1'b0 & p1_loss == 1'b0) \n  nextState = Loss; \n  else if (p2_mm == 1'b0) \n  nextState = P2_Move; \n  end \n  P2_Move: \n  begin \n  verifica_status <= 1'b0; \n  turno_p1 <= 1'b0; \n  turno_p2 <= 1'b1; \n  if (p2_mm == 1'b0) \n  nextState = P2_Move; \n  else if (p2_mm == 1'b1) \n  nextState = P2_Status; \n  end \n  P2_Status: \n  begin \n  verifica_status <= 1'b1; \n  turno_p1 <= 1'b1; \n  turno_p2 <= 1'b0; \n  if (p2_tie == 1'b1 & p2_loss == 1'b0 & p2_win == 1'b0) \n  nextState = Tie; \n  else if (p2_win == 1'b1 & p2_tie == 1'b0 & p2_loss == 1'b0) \n  nextState = Win; \n  else if (p1_mm == 1'b0) \n  nextState = P1_Move; \n  end \n  Win: \n  begin \n  win_game <= 1'b1; \n  nextState = Win; \n  end \n  Tie: \n  begin \n  tie_game <= 1'b1; \n  nextState = Tie; \n  end \n  Loss: \n  begin \n  loss_game <= 1'b1; \n  nextState = Loss; \n  end \n  default: nextState = P1_Move; \n  endcase \n  end \n endmodule"}
{"task_id": "review2015_fsm", "detail_description": "We want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a state machine counter. It has an internal state register that transitions between IDLE, START, STOP, and STORE states based on various input conditions. The outputs, such as enable, level_reset, data_store, and c_idle, are controlled based on the current state. The state transitions are based on the inputs like counter_start, counter_stop, pulse_irq_counter_stop, and global_enable_reg. The module includes logic to manage these inputs and states, ensuring the outputs are appropriately controlled based on the current state of the state machine.\n\n Module header:\n\nmodule state_machine_counter #(parameter INTR_TYPE = 1'b1)(clk,reset_n,pulse_irq_counter_stop,global_enable_reg,counter_start,counter_stop,enable,c_idle,level_reset,data_store);\n [/INST]\n\nAssociated Code:  \n input wire clk; \n input wire reset_n; \n input wire pulse_irq_counter_stop; \n input wire global_enable_reg; \n input wire counter_start; \n input wire counter_stop; \n output reg enable; \n output reg level_reset; \n output reg data_store; \n output reg c_idle; \n reg [1:0] state ; \n reg [1:0] next_state ; \n localparam IDLE =2'b00; \n localparam START =2'b01; \n localparam STOP =2'b10; \n localparam STORE =2'b11; \n always @ (posedge clk or negedge reset_n) \n begin \n  if (!reset_n) state <= IDLE; \n  else state<= next_state; \n end \n always @(state or counter_start or counter_stop or pulse_irq_counter_stop or global_enable_reg) \n  begin \n  case (state) \n  IDLE: if (counter_start==1'b0 || global_enable_reg == 1'b0 || pulse_irq_counter_stop==1'b1) begin \n  next_state = IDLE; \n  end else begin \n  next_state = START; \n  end \n  START: if (global_enable_reg == 1'b0) begin \n  next_state = IDLE; \n  end \n  else if ((INTR_TYPE == 0 & counter_stop==1'b1) |(INTR_TYPE == 1 & pulse_irq_counter_stop==1'b1)) \n  begin \n  next_state = STOP; \n  end \n  else \n  begin \n  next_state = START; \n  end \n  STOP: begin \n  next_state = STORE; \n  end \n  STORE: begin \n  next_state = IDLE; \n  end \n  default:next_state = IDLE; \n  endcase \n end \n always @ (state) begin \n  case (state) \n  IDLE: begin \n  enable = 1'b0; \n  level_reset = 1'b0; \n  data_store = 1'b0; \n  c_idle = 1'b1; \n  end \n  START: begin \n  enable = 1'b1; \n  level_reset = 1'b1; \n  data_store = 1'b0; \n  c_idle = 1'b0; \n  end \n  STOP: begin \n  enable = 1'b0; \n  level_reset = 1'b1; \n  data_store = 1'b0; \n  c_idle = 1'b0; \n  end \n  STORE: begin \n  enable = 1'b0; \n  level_reset = 1'b1; \n  data_store = 1'b1; \n  c_idle = 1'b0; \n  end \n  endcase \n end \n endmodule"}
{"task_id": "conwaylife", "detail_description": "The \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.Use the following description and code as an example:\nDescription: \n\nThis Verilog module is an implementation of the Conway's Game of Life cellular automaton. It takes an input grid of states and applies the rules of the game to calculate the next state of each cell. The output grid of states represents the next generation of the game. The module defines the grid size using parameters WIDTH and HEIGHT. It initializes the boundary cells to zero, and for the inner cells, it calculates the sum of neighboring cell states to determine the next state using the rules of the Game of Life.\n\n Module header:\n\nmodule conway #(parameter WIDTH = 32,parameter HEIGHT = 32)(in_states,out_states);\n [/INST]\n\nAssociated Code:  \n  input [WIDTH*HEIGHT-1:0] in_states; \n  output [WIDTH*HEIGHT-1:0] out_states; \n  genvar r, c; \n  generate \n  for (c = 0; c < WIDTH; c=c+1) begin \n  assign out_states[c] = 0; \n  assign out_states[(HEIGHT-1)*WIDTH + c] = 0; \n  end \n  for (r = 1; r < HEIGHT-1; r=r+1) begin \n  assign out_states[r * WIDTH] = 0; \n  assign out_states[(r + 1) * WIDTH - 1] = 0; \n  for (c = 1; c < WIDTH-1; c=c+1) begin \n  wire cur_state_i; \n  wire [4:0] sum_i; \n  assign cur_state_i = in_states[r * WIDTH + c]; \n  assign sum_i = in_states[r * WIDTH + c-WIDTH-1] + in_states[r * WIDTH + c-WIDTH] + in_states[r * WIDTH + c-WIDTH+1] + in_states[r * WIDTH + c-1] + in_states[r * WIDTH + c+1] + in_states[r * WIDTH + c+WIDTH-1] + in_states[r * WIDTH + c+WIDTH] + in_states[r * WIDTH + c+WIDTH+1]; \n  wire eq2_i, eq3_i; \n  assign eq2_i = (sum_i == 2); \n  assign eq3_i = (sum_i == 3); \n  wire next_state_i; \n  assign next_state_i = (cur_state_i & (eq2_i | eq3_i)) | (~cur_state_i & eq3_i); \n  assign out_states[r * WIDTH + c] = next_state_i; \n  end \n  end \n  endgenerate \n endmodule"}
{"task_id": "lemmings3", "detail_description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.Use the following description and code as an example:\nDescription: \n\nThe Verilog module \"gift_control\" is a ball game controller. It includes a counter and random number generator. It updates the game state based on input signals and generates various outputs to control the game elements such as paddle size, speed, ball behavior, and block dropping. It also includes logic to handle game events like getting shot or dropping a block. The module uses the clock signal to synchronize the state updates and output generation.\n\n Module header:\n\nmodule gift_control(input clock, reset, enable, hit,input [9:0] in_x, in_y,output reg [2:0] kind,output reg [9:0] x, y,output reg active,output reg paddle_size, paddle_speed, give_ball, ball_speed, ball_size, ball_display, get_shot, drop_block);\n [/INST]\n\nAssociated Code:  \n localparam CHP = 3'b000; \n localparam SPP = 3'b001; \n localparam GBL = 3'b010; \n localparam SPB = 3'b011; \n localparam CHB = 3'b100; \n localparam HID = 3'b101; \n localparam SOT = 3'b110; \n localparam DRP = 3'b111; \n wire [31:0] num; \n wire [UBIT-1:0] cnt; \n assign rst = reset || cnt >= UNIT/10; \n counter #(UBIT) cnt0(clock, rst, active, cnt); \n rand r_gen(clock, reset, num); \n always @ (posedge clock) \n begin \n  if (reset || y >= TOP+MAXY || hit) \n  active <= 1'b0; \n  else if (enable && num[15:14] == 2'b00) \n  active <= 1'b1; \n end \n always @(posedge clock) \n begin \n  if (active) begin \n  if (rst) y <= y+1; \n  end else if (enable) begin \n  x <= in_x; \n  y <= in_y; \n  kind <= num[2:0]; \n  end \n end \n always @(posedge clock) \n begin \n  if (active && hit) begin \n  if (kind == CHP) paddle_size <= 1'b1; \n  if (kind == SPP) paddle_speed <= 1'b1; \n  if (kind == GBL) give_ball <= 1'b1; \n  if (kind == SPB) ball_speed <= 1'b1; \n  if (kind == CHB) ball_size <= 1'b1; \n  if (kind == HID) ball_display <= 1'b1; \n  if (kind == SOT) get_shot <= 1'b1; \n  if (kind == DRP) drop_block <= 1'b1; \n  end else begin \n  paddle_size <= 1'b0; \n  paddle_speed <= 1'b0; \n  give_ball <= 1'b0; \n  ball_speed <= 1'b0; \n  ball_size <= 1'b0; \n  ball_display <= 1'b0; \n  get_shot <= 1'b0; \n  drop_block <= 1'b0; \n  end \n end \n endmodule"}
{"task_id": "count_clock", "detail_description": "Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.Use the following description and code as an example:\nDescription: \n\nThis Verilog module serves as a clock counter. It increments the time in seconds, minutes, and hours based on the clock signal and resets when the load signal transitions from high to low. The output signals chour2, chour1, cminute2, cminute1, csecond2, and csecond1 represent the updated time values. The clock starts from 00:00:00 and increments the time until it reaches 23:59:59.\n\n Module header:\n\nmodule run_clock (nLoad, Clk, hour2, hour1, minute2, minute1, second2, second1,chour2, chour1, cminute2, cminute1, csecond2, csecond1);\n [/INST]\n\nAssociated Code:  \n  input Clk, nLoad; \n  input [3:0] hour2, hour1, minute2, minute1, second2, second1; \n  output reg [3:0] chour2, chour1, cminute2, cminute1, csecond2, csecond1; \n  always @ (posedge Clk, negedge nLoad) \n  begin \n  if (~nLoad) \n  begin \n  chour2 <= hour2; chour1 <= hour1; cminute2 <= minute2; cminute1 <= minute1; csecond2 <= second2; csecond1 <= second1; \n  end \n  else \n  begin \n  csecond1 <= csecond1 + 1; \n  if (csecond1 > 8) \n  begin \n  csecond2 <= csecond2 + 1; \n  csecond1 <= 0; \n  end \n  if ((csecond2 == 5)&(csecond1 == 9)) \n  begin \n  cminute1 <= cminute1 + 1; \n  csecond2 <= 0; \n  csecond1 <= 0; \n  end \n  if ((cminute2 < 5) & (cminute1 == 9) & (csecond2 == 5) & (csecond1 == 9)) \n  begin \n  cminute2 <= cminute2 + 1; \n  cminute1 <= 0; \n  end \n  if ((cminute2 == 5)&(cminute1 == 9)&(csecond2 == 5)&(csecond1 == 9)) \n  begin \n  chour1 <= chour1 + 1; \n  cminute2 <= 0; \n  cminute1 <= 0; \n  end \n  if ((chour2 < 2) & (chour1 == 9) & (cminute2 == 5) & (cminute1 == 9) & (csecond2 == 5) & (csecond1 == 9)) \n  begin \n  chour2 <= chour2 + 1; \n  chour1 <= 0; \n  end \n  if ((chour2 == 2)&(chour1 == 3)&(cminute2 == 5)&(cminute1 == 9)&(csecond2==5)&(csecond1==9)) \n  begin \n  chour2 <= 0; \n  chour1 <= 0; \n  end \n  end \n  end \n endmodule"}
{"task_id": "lemmings2", "detail_description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.Use the following description and code as an example:\nDescription: \n\nThe Verilog module \"gift_control\" is a ball game controller. It includes a counter and random number generator. It updates the game state based on input signals and generates various outputs to control the game elements such as paddle size, speed, ball behavior, and block dropping. It also includes logic to handle game events like getting shot or dropping a block. The module uses the clock signal to synchronize the state updates and output generation.\n\n Module header:\n\nmodule gift_control(input clock, reset, enable, hit,input [9:0] in_x, in_y,output reg [2:0] kind,output reg [9:0] x, y,output reg active,output reg paddle_size, paddle_speed, give_ball, ball_speed, ball_size, ball_display, get_shot, drop_block);\n [/INST]\n\nAssociated Code:  \n localparam CHP = 3'b000; \n localparam SPP = 3'b001; \n localparam GBL = 3'b010; \n localparam SPB = 3'b011; \n localparam CHB = 3'b100; \n localparam HID = 3'b101; \n localparam SOT = 3'b110; \n localparam DRP = 3'b111; \n wire [31:0] num; \n wire [UBIT-1:0] cnt; \n assign rst = reset || cnt >= UNIT/10; \n counter #(UBIT) cnt0(clock, rst, active, cnt); \n rand r_gen(clock, reset, num); \n always @ (posedge clock) \n begin \n  if (reset || y >= TOP+MAXY || hit) \n  active <= 1'b0; \n  else if (enable && num[15:14] == 2'b00) \n  active <= 1'b1; \n end \n always @(posedge clock) \n begin \n  if (active) begin \n  if (rst) y <= y+1; \n  end else if (enable) begin \n  x <= in_x; \n  y <= in_y; \n  kind <= num[2:0]; \n  end \n end \n always @(posedge clock) \n begin \n  if (active && hit) begin \n  if (kind == CHP) paddle_size <= 1'b1; \n  if (kind == SPP) paddle_speed <= 1'b1; \n  if (kind == GBL) give_ball <= 1'b1; \n  if (kind == SPB) ball_speed <= 1'b1; \n  if (kind == CHB) ball_size <= 1'b1; \n  if (kind == HID) ball_display <= 1'b1; \n  if (kind == SOT) get_shot <= 1'b1; \n  if (kind == DRP) drop_block <= 1'b1; \n  end else begin \n  paddle_size <= 1'b0; \n  paddle_speed <= 1'b0; \n  give_ball <= 1'b0; \n  ball_speed <= 1'b0; \n  ball_size <= 1'b0; \n  ball_display <= 1'b0; \n  get_shot <= 1'b0; \n  drop_block <= 1'b0; \n  end \n end \n endmodule"}
{"task_id": "countbcd", "detail_description": "Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.Use the following description and code as an example:\nDescription: \n\nThis Verilog module implements a BCD counter that increments its output q on each clock cycle, and resets to zero when the reset signal is asserted. The counter outputs a carry-out signal cout when the value reaches 10, which corresponds to the binary representation of the decimal number 10.\n\n Module header:\n\nmodule bcdcounterx(reset, c, cout, q);\n [/INST]\n\nAssociated Code:  \n input reset, c; \n output reg cout; \n output reg [3:0]q; \n always @(posedge reset or posedge c) begin \n  if (reset) {cout, q} <= 0; \n  else begin \n  if (q == 9) \n  {cout, q} <= {5'b10000}; \n  else \n  {cout, q} <= q + 1'b1; \n  end \n end \n endmodule"}
